<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>二叉树的最大深度 | isekko</title>
<link rel="shortcut icon" href="https://IseEkko.github.io//favicon.ico?v=1641825320004">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://IseEkko.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="二叉树的最大深度 | isekko - Atom Feed" href="https://IseEkko.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="# 题目
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，
  3
/  \

9  2..." />
    <meta name="keywords" content="算法" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://IseEkko.github.io/">
  <img class="avatar" src="https://IseEkko.github.io//images/avatar.png?v=1641825320004" alt="">
  </a>
  <h1 class="site-title">
    isekko
  </h1>
  <p class="site-description">
    对个人笔记的总结，这个网站的笔记将会是我经过提炼过后的笔记。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              二叉树的最大深度
            </h2>
            <div class="post-info">
              <span>
                2022-01-10
              </span>
              <span>
                3 min read
              </span>
              
                <a href="https://IseEkko.github.io/tag/89sSoit-w/" class="post-tag">
                  # 算法
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><img src="https://IseEkko.github.io//post-images/1641825317112.png" alt="" loading="lazy"># 题目<br>
给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>  3
/  \
</code></pre>
<p>9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
<h1 id="思考">思考</h1>
<p>拿到这个题目我们最先想到的就是层序遍历，为什么呢？<br>
我们首先要明白层序遍历我们最后的结果是什么，层序遍历我们最后得到的是一个二位数组。<br>
那我们换个角度去看他，最大的深度是不是就是层序遍历最后二维数组的层数。答案是肯定的。<br>
上面是我最先能使用的方法。</p>
<h1 id="解题">解题</h1>
<p>这里解题的方式有两种</p>
<h2 id="递归法">递归法</h2>
<p>这里我们回顾一下递归的三个要素。根据三要素来书写代码。<br>
1. 确定输入和返回值<br>
2. 确定终止条件<br>
3. 确定单层逻辑<br>
那么下面我们来详细的书写一下代码<br>
首先我们确定输入和返回值，这里我们首先输入的肯定是节点，然后返回的是深度</p>
<pre><code> function fun(){
    func getDepths(root *TreeNode) int
 }
 fun();
</code></pre>
<p>第二步是确定终止的条件，这里我们终止的条件是节点是nil<br>
if root ==nil{<br>
return 0<br>
}<br>
第三步确定单层的逻辑<br>
Left := getDepths(root.Left)<br>
Right := getDepths(root.Right)<br>
deth := 1 + max(Left,Right)<br>
这里需要注意的是，我们最后得到的是高度，这里的高度是需要加一的。</p>
<p>最后的源码：</p>
<pre><code>func maxDepth(root *TreeNode) int {
   return getDepths(root)
}

func getDepths(root *TreeNode) int{
    if root ==nil{
        return 0
    }
    Left := getDepths(root.Left)
    Right := getDepths(root.Right)
    deth := 1 + max(Left,Right)
    return deth
}

func max(Left,Right int)int{
    if Left &gt; Right{
        return Left
    }
        return Right
}
</code></pre>
<h3 id="迭代法">迭代法</h3>
<p>这个方法也就是我之前想到的那个方法，也就是使用层讯遍历去完成这个题目，这里我们就不在过多的解析<br>
在后面的层序遍历的地方我会把这段代码详细的解析一遍。</p>
<pre><code>func maxDepth(root *TreeNode) int {
    var res [][]int
    if root == nil{
        return 0
    }
    st:= list.New()
    st.PushBack(root)
    var Arrtem []int
    for st.Len() &gt; 0{
        lenth := st.Len()
        for i := 0;i&lt;lenth;i++{
            node := st.Remove(st.Front()).(*TreeNode)
            if node.Left != nil{
                st.PushBack(node.Left)
            }
            if node.Right != nil{
                st.PushBack(node.Right)
            }
            Arrtem = append(Arrtem,node.Val)
        }
        res  = append(res,Arrtem)
        Arrtem = []int{}
    }
    result := len(res)
  return result
}

</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%80%9D%E8%80%83">思考</a></li>
<li><a href="#%E8%A7%A3%E9%A2%98">解题</a>
<ul>
<li><a href="#%E9%80%92%E5%BD%92%E6%B3%95">递归法</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95">迭代法</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://IseEkko.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
