<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>isekko</title>
    <updated>2022-01-15T12:22:13.541Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>对个人笔记的总结，这个网站的笔记将会是我经过提炼过后的笔记。</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, isekko</rights>
    <entry>
        <title type="html"><![CDATA[GIN学习]]></title>
        <id>https://IseEkko.github.io/post/gin-xue-xi/</id>
        <link href="https://IseEkko.github.io/post/gin-xue-xi/">
        </link>
        <updated>2022-01-14T09:22:02.000Z</updated>
        <summary type="html"><![CDATA[<p>详细的学习gin的知识点，不是第一次学习了，这次梳理一个学习的文档出来</p>
]]></summary>
        <content type="html"><![CDATA[<p>详细的学习gin的知识点，不是第一次学习了，这次梳理一个学习的文档出来</p>
<!-- more -->
<h1 id="第一个gin程序">第一个gin程序</h1>
<pre><code> 这里我们开始演示一下gin的开始程序，也就是快速入门。
 我们来看一下代码：
</code></pre>
<pre><code>package main

import &quot;github.com/gin-gonic/gin&quot;

func main() {
	r := gin.Default()
	r.GET(&quot;/ping&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;pong&quot;,
		})
	})
	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}
</code></pre>
<p>这里我们详细的拆分一下这个代码，</p>
<h2 id="导包">导包</h2>
<p>这里我们可以使用go mod进行包的导入</p>
<h2 id="代码细节">代码细节</h2>
<p>第一行代码</p>
<pre><code>	r := gin.Default()
</code></pre>
<p>这个一行代码，就是产生了一个gin的实例<br>
然后后面进行操作，</p>
<pre><code>r.GET(&quot;/ping&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;pong&quot;,
		})
	})
</code></pre>
<p>这里面首先有一个GET方法，对于这个GET方法我们首先来看一下它的源码</p>
<pre><code>// GET is a shortcut for router.Handle(&quot;GET&quot;, path, handle).
func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {
	return group.handle(http.MethodGet, relativePath, handlers)
}
</code></pre>
<p>看到源码我们可以看到里面的参数，首先第一个参数就是注册的路径，然后第二个就是处理器的注册。<br>
在这里我们注册的是一个匿名函数。当然我们也可以修改成：</p>
<pre><code>
func  pong(c *gin.Context)  {
	c.JSON(200, gin.H{
		&quot;message&quot;: &quot;pong&quot;,
	})
}
func main() {
	r := gin.Default()
	r.GET(&quot;/ping&quot;, pong)
	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}
</code></pre>
<p>在这里我们需要注意的就是这个函数的类型要是：func  (c *gin.Context)<br>
然后我们可以发现在传递参数的里面，我们使用的是gin.H<br>
我们点开它的源码：</p>
<pre><code>// H is a shortcut for map[string]interface{}
type H map[string]interface{}
</code></pre>
<p>我们看到了它就是一个map类型，因为在gin中经常使用的原因，所以开发者对它进行了封装。这样我们使用起来就更加的方便。</p>
<h1 id="gin中new和default的不同">gin中new和Default的不同</h1>
<p>在这里我们介绍两个方法，他们返回回来的都是一个*Engine<br>
那么它们有什么不一样呢，在这里我们要知道的是不一样的点是使用Default后它会默认开启两个中间件，一个是recover一个是logger。</p>
<h1 id="路由分组和url">路由分组和URL</h1>
<p>在我们的开发中，我们为了程序的可读性，我们一般会把路由进行分组。<br>
也是为了后期更好的寻找路由。<br>
那么我们如何进行分组呢？<br>
我们使用的是Group方法。</p>
<pre><code>package main

import &quot;github.com/gin-gonic/gin&quot;

func  pong(c *gin.Context)  {
	c.JSON(200, gin.H{
		&quot;message&quot;: &quot;pong&quot;,
	})
}
//演示分组
func main() {
	r := gin.Default()
    group := r.Group(&quot;/v1&quot;)
	{
		group.GET(&quot;/ping&quot;, pong)
	}

	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}
</code></pre>
<h1 id="获取url参数">获取url参数</h1>
<p>这里我们通过url传入参数，那么我们怎么操作呢?</p>
<pre><code>package main

import &quot;github.com/gin-gonic/gin&quot;

func  pong(c *gin.Context)  {
	id := c.Param(&quot;id&quot;)
	c.JSON(200, gin.H{
		&quot;message&quot;: id,
	})
}
//演示分组
func main() {
	r := gin.Default()
    group := r.Group(&quot;/v1&quot;)
	{
		group.GET(&quot;/:id&quot;, pong)
	}

	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}
</code></pre>
<p>但是呢我们可以发现这个东西是有问题的，我们这里设定的是id，按照我们常识这里，我们知道id一般来说是数字，但是这里不管是数值还是什么都可以传输。<br>
那么我们怎么进行限制呢？<br>
这里我们运用到了之后的表单验证的方式。</p>
<pre><code>package main

import (
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

type Person struct {
	ID string `uri:&quot;id&quot; binding:&quot;required,uuid&quot;`
	Name string `uri:&quot;name&quot; binding:&quot;required&quot;`
}
func main() {
	r := gin.Default()
    r.GET(&quot;/:name/:id&quot;, func(context *gin.Context) {
		var person Person
		if err := context.ShouldBindUri(&amp;person);err != nil{
		context.Status(404)
		return
		}
		context.JSON(http.StatusOK,gin.H{
			&quot;name&quot;:person.Name,
			&quot;id&quot;:person.ID,
		})
	})

	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}
</code></pre>
<h1 id="获取get和post参数">获取GET和POST参数</h1>
<p>这两种方式是我们比较常见的方式。那么下面我们详细的说明一下</p>
<h2 id="get">GET</h2>
<p>使用到的方法有两个一个是DefaultQuery和Query。这两个方法的区别在于，前者是可以有默认值的，后者不能设置默认值</p>
<pre><code>package main

import (
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	r := gin.Default()
    r.GET(&quot;/name&quot;,name)

	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}

func name(c *gin.Context){
	name := c.DefaultQuery(&quot;name&quot;,&quot;lzz&quot;)
	c.JSON(http.StatusOK,gin.H{
		&quot;name&quot;:name,
	})
}
</code></pre>
<h2 id="post">POST</h2>
<p>在post中我们要取出参数，我们也有两个方法，两个方法的区别和上面是一样的。<br>
分别是DefaultPostForm和PostForm。</p>
<pre><code>package main

import (
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	r := gin.Default()
    r.POST(&quot;/postname&quot;,Postname)
	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}

func Postname(c *gin.Context) {
	posrname := c.DefaultPostForm(&quot;name&quot;,&quot;lzz&quot;)
	c.JSON(http.StatusOK,gin.H{
		&quot;name&quot;:posrname,
	})
}
</code></pre>
<h1 id="关于gin表单验证">关于gin表单验证</h1>
<pre><code> 我们在做web开发的时候，肯定是会遇见表单验证的需求的，表单验证也是为了一定的安全性。
</code></pre>
<p>关于表单验证这里我们直接上代码，详情可以查看官方文档。</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

type LoginForm struct {
	User string `form:&quot;user1&quot; json:&quot;user&quot; binding:&quot;required,min=3,max=10&quot;`
	Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`
}

type SignUpForm struct {
	Age        uint8  `form:&quot;age&quot; json:&quot;age&quot; binding:&quot;gte=1,lte=130&quot;`
	Name       string `form:&quot;name&quot; binding:&quot;required,min=3&quot;`
	Email      string `form:&quot;email&quot; binding:&quot;required,email&quot;`
	Password   string `form:&quot;password&quot; binding:&quot;required&quot;`
	RePassword string `form:&quot;re_password&quot; binding:&quot;required,eqfield=Password&quot;`
}
func main() {
   router := gin.Default()
   router.POST(&quot;/login&quot;, func(c *gin.Context) {
	   var login LoginForm
	  if  err := c.ShouldBind(&amp;login);err != nil{
		  fmt.Println(err.Error())
		 c.JSON(http.StatusBadRequest,gin.H{
			  &quot;err&quot;: err.Error(),
		  })
		  return
	  }
		  c.JSON(http.StatusOK,gin.H{
			  &quot;msg&quot;:&quot;登录成功&quot;,
		  })
   })
   router.POST(&quot;/sigin&quot;, func(context *gin.Context) {
	var siginUpForm  SignUpForm
	if err := context.ShouldBind(&amp;siginUpForm); err != nil{
		fmt.Println(err.Error())
		context.JSON(http.StatusBadRequest,gin.H{
			&quot;err&quot;:err.Error(),
		})
		return
	}
	context.JSON(http.StatusOK,gin.H{
		&quot;msg&quot;:&quot;成功&quot;,
	})
   })
   router.Run()
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径总和]]></title>
        <id>https://IseEkko.github.io/post/lu-jing-zong-he/</id>
        <link href="https://IseEkko.github.io/post/lu-jing-zong-he/">
        </link>
        <updated>2022-01-14T07:16:36.000Z</updated>
        <summary type="html"><![CDATA[<p>计算二叉树路径上的和，是不是等于目标值。</p>
]]></summary>
        <content type="html"><![CDATA[<p>计算二叉树路径上的和，是不是等于目标值。</p>
<!-- more -->
<h1 id="题目">题目</h1>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点。<br>
示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="" loading="lazy"><br>
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>
输出：true<br>
解释：等于目标和的根节点到叶节点路径如上图所示。<br>
示例 2：<br>
<img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="" loading="lazy"><br>
输入：root = [1,2,3], targetSum = 5<br>
输出：false<br>
解释：树中存在两条根节点到叶子节点的路径：<br>
(1 --&gt; 2): 和为 3<br>
(1 --&gt; 3): 和为 4<br>
不存在 sum = 5 的根节点到叶子节点的路径。<br>
示例 3：</p>
<p>输入：root = [], targetSum = 0<br>
输出：false<br>
解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="思路">思路</h1>
<p>这一个题目的思路不是很难，只是需要判断的东西会多一些，但是总体来说还是简单的。<br>
这里我们还是使用递归来解答这个题目，使用的方法还是递归的三步骤</p>
<h1 id="解题">解题</h1>
<h3 id="首先确认须传入的参数和返回的参数值">首先确认须传入的参数和返回的参数值</h3>
<pre><code>   这个题目最终是要判断是不是符合条件，所以我们的返回值我们用bool类型。因为我们还是对节点进行操作，所以我们传入的参数也就是节点，因为我们还要进行数值的判断，所以我们还要传入这个需要比对的值。
</code></pre>
<pre><code>trave(root *TreeNode,targetSum int)bool
</code></pre>
<h3 id="确定终止条件">确定终止条件</h3>
<p>这里我们的终止条件就是看到最后叶子节点的时候，我们最后得到的值是是不是对应的值<br>
也就是：</p>
<pre><code>  if root.Left == nil&amp;&amp; root.Right == nil&amp;&amp; targetSum == 0{
        return true
    }
    if root.Left == nil&amp;&amp; root.Right == nil{
        return false
    }
</code></pre>
<h3 id="确定单层逻辑">确定单层逻辑</h3>
<p>这里我们确认一些单层的逻辑，也就是在这里我们用到了回溯的思想，如果我们没有找到相应的路径我们就回溯然后再次寻找，直到确认返回为止。</p>
<pre><code>if root.Left != nil{
        targetSum = targetSum - root.Left.Val
        if trave(root.Left,targetSum){
            return true
            }
        targetSum = targetSum + root.Left.Val
        }
    if root.Right != nil {
        targetSum = targetSum-root.Right.Val
        if trave(root.Right,targetSum){
            return true
            }
        targetSum = targetSum+root.Right.Val
    }
    return false
</code></pre>
<h1 id="解题源码">解题源码</h1>
<p>最后我们通过上面的步骤得到了最终的代码；</p>
<pre><code>func hasPathSum(root *TreeNode, targetSum int) bool {
if root == nil{
    return false
}
return trave(root,targetSum-root.Val)
}
func trave(root *TreeNode,targetSum int)bool{
    if root.Left == nil&amp;&amp; root.Right == nil&amp;&amp; targetSum == 0{
        return true
    }
    if root.Left == nil&amp;&amp; root.Right == nil{
        return false
    }

    if root.Left != nil{
        targetSum = targetSum - root.Left.Val
        if trave(root.Left,targetSum){
            return true
            }
        targetSum = targetSum + root.Left.Val
        }
    if root.Right != nil {
        targetSum = targetSum-root.Right.Val
        if trave(root.Right,targetSum){
            return true
            }
        targetSum = targetSum+root.Right.Val
    }
    return false
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的所有路径]]></title>
        <id>https://IseEkko.github.io/post/er-cha-shu-de-suo-you-lu-jing/</id>
        <link href="https://IseEkko.github.io/post/er-cha-shu-de-suo-you-lu-jing/">
        </link>
        <updated>2022-01-14T06:41:41.000Z</updated>
        <summary type="html"><![CDATA[<p>关于二叉树的所有路径的题目，这里我们是用递归的思想写出来的题目</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于二叉树的所有路径的题目，这里我们是用递归的思想写出来的题目</p>
<!-- more -->
<h1 id="题目">题目</h1>
<p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。<br>
叶子节点 是指没有子节点的节点。<br>
示例 1：<br>
<img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="" loading="lazy"><br>
输入：root = [1,2,3,null,5]<br>
输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]<br>
示例 2：</p>
<p>输入：root = [1]<br>
输出：[&quot;1&quot;]</p>
<h1 id="思路">思路</h1>
<p>我们这里使用的是递归的思想，也就是递归的三步骤，我们按照三步骤逐步的向下写</p>
<h1 id="解题过程">解题过程</h1>
<p>首先我们思考第一步</p>
<h3 id="定义函数确定返回值和输入值">定义函数确定返回值和输入值</h3>
<p>func(node *TreeNode,path string)<br>
这里传入的值是节点，然后和路径</p>
<h3 id="确定终止条件">确定终止条件</h3>
<p>这的终止条件有些不一样，开始写的时候，我写的条件是</p>
<pre><code>if root == nil{
    ...
}
</code></pre>
<p>显然这里的题目条件没有这么简单，所以我们这里需要注意一下这里的条件 ，因为如果是我之前书写的条件，那么我们后面就会有一大堆的判断，显然是不合理的。所以我们这里要思考一些终止条件。<br>
我们知道，我们路径终止的条件是什么，是节点左右节点都为空，所以我们的终止条件就来了。</p>
<pre><code>if (node.Left ==nil &amp;&amp; node.Right == nil){
</code></pre>
<p>上面就是我们的终止条件</p>
<h3 id="单层逻辑">单层逻辑</h3>
<p>这里的单层逻辑就不过多的赘述，我们直接上代码</p>
<pre><code>  if (node.Left ==nil &amp;&amp; node.Right == nil){
              s  := path + strconv.Itoa(node.Val)
              res = append(res,s)
              return
          }
          path = path + strconv.Itoa(node.Val) + &quot;-&gt;&quot;
          if node.Left != nil{
             allpath(node.Left,path)
          }
          if node.Right != nil{
              allpath(node.Right,path)
          }
</code></pre>
<h1 id="最终题目代码">最终题目代码</h1>
<pre><code>func binaryTreePaths(root *TreeNode) []string { 
      var res []string
      var allpath func(node *TreeNode,path string)
      allpath = func(node *TreeNode,path string){
          if (node.Left ==nil &amp;&amp; node.Right == nil){
              s  := path + strconv.Itoa(node.Val)
              res = append(res,s)
              return
          }
          path = path + strconv.Itoa(node.Val) + &quot;-&gt;&quot;
          if node.Left != nil{
             allpath(node.Left,path)
          }
          if node.Right != nil{
              allpath(node.Right,path)
          }
      }
      allpath(root,&quot;&quot;)
      return res
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GORM-使用]]></title>
        <id>https://IseEkko.github.io/post/gorm-lian-jie/</id>
        <link href="https://IseEkko.github.io/post/gorm-lian-jie/">
        </link>
        <updated>2022-01-13T11:57:14.000Z</updated>
        <summary type="html"><![CDATA[<p>这里将总结出使用gorm中的方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里将总结出使用gorm中的方法</p>
<!-- more -->
<h1 id="开始连接">开始连接</h1>
<p>这里我们将开始学习使用gorm连接数据库，这里我们要知道后面我们使用的方法都是通过连接获取的对象进行操作的。那么下面我们就开始创建这个连接。</p>
<p>当然最开始我们肯定是要导入gorm包的，这里我们就不再展示了</p>
<p>这里在连接的时候，我们这里肯定是要先书写连接dns</p>
<pre><code>dsn := &quot;用户名:密码@tcp(ip:3306)/数据库名称?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;
</code></pre>
<p>写好了这个连接名过后，使用 gorm.Open()进行连接的创建</p>
<pre><code>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
		Logger: newLogger,
	})
</code></pre>
<p>上面我们就创建好了这个连接对象，然后后面的操作我们将在这个基础上进行。</p>
<h1 id="基础使用的设置">基础使用的设置</h1>
<h2 id="配置彩色打印与日志级别">配置彩色打印与日志级别</h2>
<p>在前面我们说到，我们可能会对sql敏感度会降低，这里我们将解决这个尴尬的问题，我们这里可以让执行的sql语句打印出来，这里我们直接上代码是怎么配置的。</p>
<pre><code>/**
	进行日志配置，这里配置可以让他打印出sql
	 */
	newLogger := logger.New(
		log.New(os.Stdout, &quot;\r\n&quot;, log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容——译者注）
		logger.Config{
			SlowThreshold: time.Second,   // 慢 SQL 阈值
			LogLevel:      logger.Info, // 日志级别
			IgnoreRecordNotFoundError: true,   // 忽略ErrRecordNotFound（记录未找到）错误
			Colorful:      true,         // 禁用彩色打印
		},
	)
    //这里这个db就是生成的对象
	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
		Logger: newLogger,
	})
</code></pre>
<p>这里我们就配置好了彩色打印。<br>
这里我们设置的是全局的配置，也就是说，会打印出所有的语句。</p>
<h2 id="设置表名">设置表名</h2>
<p>在开发的时候，我们知道在gorm中，我们添加表我们是先写好一个结构体，然后结构体的名称会影响最后生成表名的名称。这里我们有个需求也就是自定义表名的需求那么我们如何完成呢。这里我们将介绍两个办法。</p>
<h3 id="通过方法进行修改">通过方法进行修改</h3>
<p>通过实现一个接口去实现对表名称的修改：</p>
<pre><code>func(Language) TableName()string{
 return &quot;my_language&quot;
}
</code></pre>
<p>在这里返回的值就是最后表的名称</p>
<h3 id="通过配置完成名称前缀的添加">通过配置完成名称前缀的添加</h3>
<pre><code>	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   &quot;mwwx&quot;,

		},
		Logger: newLogger,
	})
</code></pre>
<p>这里我们使用的是在生成连接对象的地方进行添加，我们在gorm.Open()中我们配置NamingStrategy: schema.NamingStrategy{}进行配置。这里我们添加的是表的前缀</p>
<h3 id="需要注意的地方">需要注意的地方</h3>
<p>这里我们需要注意的是。前面两个方法只能使用一个两个不能同时的使用，这里是需要我们注意的点。</p>
<h1 id="基本的curd">基本的curd</h1>
<h2 id="创建表">创建表</h2>
<pre><code>  在对数据进行操作之前，我们肯定是要先进行数据表的创建的，这里我们看一下我们如何使用gorm进行数据表的创建。
</code></pre>
<p>使用的方法是：AutoMigrate()</p>
<pre><code> db.AutoMigrate(&amp;表结构体{})
</code></pre>
<p>这里需要注意的是我们这里使用的是结构体的</p>
<h2 id="添加数据">添加数据</h2>
<p>有了数据表过后那么我们就要开始添加数据。</p>
<h3 id="添加单条数据">添加单条数据</h3>
<pre><code>//下面我们将会演示一个特殊的操作
 user := User{
	 Name: &quot;lzz&quot;,
 }
 //这里我们需要注意的点，也就是这里我们在创建的时候使用的是地址
 //然后我们这里是有返回值的
 result := db.Create(&amp;user)
 //下面的步骤我们必须是有上面的操作过后才会有的操作。
 fmt.Println(user.ID)
 fmt.Println(result.Error)//错误
 fmt.Println(result.RowsAffected)//返回更新的条数
</code></pre>
<p>在这里我们可以看到添加单条数据的方法，然后我们可以看到最后的有三行代码，从中我们可以学习到，创建完对象过后我们可以做的操作和可以得到的数据。</p>
<h3 id="批量添加数据">批量添加数据</h3>
<p>在批量添加数据中我们有两种方式可以完成。</p>
<h4 id="使用create">使用create</h4>
<p>这里我们使用到的方式是create</p>
<pre><code>var users = []User{
		{Name: &quot;lzz1&quot;},{Name: &quot;lzz2&quot;},{Name: &quot;lzz3&quot;},
	}
	result := db.Create(&amp;users)
</code></pre>
<p>这里我们可以清楚的看到，我们首先是创建了一个切片，然后我们使用切片去插入数据</p>
<h4 id="使用createinbatches">使用CreateInBatches</h4>
<p>这里我们使用的方法是使用CreateInBatches，为什么要使用这个方法呢，是因为上面的方法和这个方法的sql中我们就要看出差距，我们首先要知道的是，sql语句的长度是有限制的，但是上面的方法，在批量插入的时候，把所有的值都放到了一个sql里面，那么问题就来了这样的话当数据量很大的时候，由于sql是有限制的所有就会出错。这个时候我们就使用CreateInBatches这个方法，因为这个方法可以设定批量每一条sql的数量。</p>
<pre><code>//这里可以设置提交几个数据，然后这里就是分批次进行创建
  //那么我们为什么要用这个呢？是因为sql语句是有长度限制的，也就是数据量大的时候我们是没有办法
  //进行传输的。这里进行限制的时候后面的数字代表的是一次创建创建几个数据。
  db.CreateInBatches(users,2)
</code></pre>
<p>从上面我们就可以看出我们使用的方式。</p>
<h1 id="查询">查询</h1>
<p>在使用gorm查询的时候，我们也有很多的点需要注意，在这里进行一个总结。</p>
<h2 id="基本查询">基本查询</h2>
<p>在基本的查询中，我们使用的方法有first和find这个两个，对于这个两个方法，第一个查询的时候是根据主键进行排序的，返回第一条数据。然后find呢是返回的所有数据。</p>
<pre><code>var product Product
  db.First(&amp;product, 1) // 根据整形主键查找
  db.First(&amp;product, &quot;code = ?&quot;, &quot;D42&quot;) // 查找 code 字段值为 D42 的记录
</code></pre>
<p>find方式：</p>
<pre><code>//使用find会检索所有的对象。
var users []User
result := db.Find(&amp;users)
fmt.Println(&quot;总共记录：&quot;,result.RowsAffected)
</code></pre>
<p>当然肯定是不只是这些方式的：<br>
对于其他的方式我们可以直接查看官方的文档。在我前一篇博客中有书写。</p>
<h2 id="在查询中需要使用的where">在查询中需要使用的where</h2>
<pre><code>//在实际的开发中我们会加入很多的where语句的
  db.Where(&quot;name = ?&quot;,&quot;lzz&quot;).First(&amp;users)
	//对于这里我们还可以这样去做查询，这样可以屏蔽很多的细节
	db.Where(&amp;User{Name: &quot;lzz&quot;}).First(&amp;users)
	fmt.Println(users.ID)
     //在文档里面我们可以知道，我们还可以使用map，map和slice不同在于哪里？
	 //在于map不会屏蔽零值
	 /**
	 查询方式条件我们有三种方式：
	    1. string
	    2. struct
	    3. map
	 在这里面我们优先选择后两种。可读性更强
	  */
</code></pre>
<h2 id="需要注意的点">需要注意的点</h2>
<p>这里我们需要注意的是。我们使用的时候我们需要注意，因为我们使用的是地址，所以最后返回回来的数据，就在变量里面<br>
在这里我们要是处理的时候我们没有查找到数据，是会有报错的<br>
在这里我们使用最正规的的报错方式，这个方式可以准确的判断是不是没有找到数据</p>
<h1 id="更新">更新</h1>
<p>更新这一板块也有很多常用的知识和需要注意的点</p>
<h2 id="基础的更新">基础的更新</h2>
<pre><code>db.Model(&amp;product).Update(&quot;Price&quot;, 200)
</code></pre>
<p>这里是我们更新product表中的pricei字段为200<br>
上面就是我们最基本的更新操作。</p>
<h2 id="更新的时候遇见零值问题">更新的时候遇见零值问题</h2>
<pre><code> 这里我们需要注意的是，在gorm更新操作的时候，默认是不更新零值字段的。但是我们在实际的开发中肯定是有相关需求的，那么我们如何来解决这个问题呢？
</code></pre>
<h3 id="首先使用内置的函数sqlnullxxx">首先使用内置的函数sql.nullXXX</h3>
<p>在gorm中我们是有相关的解决函数的，这里我们演示string类型字段零值的更新操作</p>
<pre><code>	db.Model(&amp;product).Updates(Product{Price: 200, Code: sql.NullString{
			String: &quot;&quot;,
			Valid:  true,
		}})
</code></pre>
<p>如果接收更新零值我们这里第二个参数一定要改成true这样我们的方法才会生效。</p>
<h3 id="改变字段结构体的类型">改变字段结构体的类型</h3>
<p>这里我们将字段的string类型改成了*string类型，那么他是可以更新零值的。</p>
<pre><code>type User struct {
	ID           uint
	Name         string
	Email        *string
	Age          uint8
	Birthday     *time.Time
	MemberNumber sql.NullString
	ActivatedAt  sql.NullTime
	CreatedAt    time.Time
	UpdatedAt    time.Time
}
//这里更新操作是会更新零值的
 db.Model(&amp;User{ID: 1}).Update(&quot;Name&quot;,&quot;&quot;)
</code></pre>
<h2 id="批量更新">批量更新</h2>
<p>批量更新的时候我们使用的是updates这个方法，</p>
<pre><code>db.Model(&amp;product).Updates(map[string]interface{}{&quot;Price&quot;: 200, &quot;Code&quot;: &quot;F42&quot;})
</code></pre>
<h3 id="需要注意的点-2">需要注意的点</h3>
<p>这里我们需要注意的是update会更新零值，但是updates不会更新零值。</p>
<h1 id="删除">删除</h1>
<p>对于删除我们需要知道的点就是软删除和物理删除两个<br>
在目前的市场上我们现在做到一般都是软删除，很少物理删除了，这里我们说一下gorm的软删除和物理删除。<br>
在gorm中，我们需要进行软删除的换，我们需要在结构体里面嵌套一个，gorm.model结构体，主要的是DeletedAt    gorm.DeletedAt字段，这个字段必须是gorm.DeletedAt这个类型的，这样我们删除的时候就是软删除了。<br>
那么我们需要物理删除我们应该怎么做呢?</p>
<pre><code>db.Unscoped().Delete(&amp;NewUser{ID: 2})
}
</code></pre>
<pre><code> 使用这个方法我们就可以进行物理删除了。
</code></pre>
<h1 id="结尾">结尾</h1>
<p>最后我们这里总结的是一些基本的时候，和我们常用的curd使用的方法，当然总结的不是很到位，希望大家多多指教，后面我将会更新连表和钩子函数的总结。随后我也会把demo放在github上供大家查看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gorm介绍]]></title>
        <id>https://IseEkko.github.io/post/gorm-jie-shao/</id>
        <link href="https://IseEkko.github.io/post/gorm-jie-shao/">
        </link>
        <updated>2022-01-11T11:03:42.000Z</updated>
        <summary type="html"><![CDATA[<p>gorm让我们从繁琐的sql中解脱出来，<br>
努力的学习gorm，但是也别忘记了sql是怎么写的</p>
]]></summary>
        <content type="html"><![CDATA[<p>gorm让我们从繁琐的sql中解脱出来，<br>
努力的学习gorm，但是也别忘记了sql是怎么写的</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1641899816277.png" alt="" loading="lazy"></figure>
<h1 id="gorm">GORM</h1>
<p>这里不是我第一次学习gorm，只是这次想具体的去学习一下这个gorm，因为我的sql能力很弱，在写项目的时候清楚的看到了自己的不足，还有就是对gorm使用的不足，这里最关键的就是我其实对sql学得不是很好，后面还要更新对sql的学习，越到后面越发现这基础的重要性。</p>
<h1 id="什么是gorm">什么是GORM</h1>
<p>gorm就是go中封装的一种orm，orm对象关系映射，对于我们理解来说，就是一个为了让我们更好的操作数据库的一个工具。<br>
下面我把官网放在下面。<br>
<a href="https://gorm.io/zh_CN/docs/index.html">GORM官网中文文档</a></p>
<h1 id="对于gorm的感觉">对于GORM的感觉</h1>
<p>其实对于这个gorm呢，在开发的时候确实速度是很快的，我们不用过多的在意sql是怎么写的。但是这样会弱化我们对sql的理解，所以我们觉得这个东西对于我们大学生来说，我认为我们写每一个方法的时候，我们多在意一下它生成的sql这样，我们不会弱化了我们对sql的理解。<br>
当然了。我的sql很菜，我还是字学习gorm的时候，好好的学习一下sql，系统的学习一下。</p>
<p>上面就是我给大家分享的gorm，下面我将会更新gorm中使用的细节。<br>
有那里写的不好的地方，希望大家多指教指教。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[平衡二叉树]]></title>
        <id>https://IseEkko.github.io/post/ping-heng-er-cha-shu/</id>
        <link href="https://IseEkko.github.io/post/ping-heng-er-cha-shu/">
        </link>
        <updated>2022-01-11T07:34:17.000Z</updated>
        <summary type="html"><![CDATA[<p>什么是平衡二叉树？<br>
我们应该怎么去判断？</p>
]]></summary>
        <content type="html"><![CDATA[<p>什么是平衡二叉树？<br>
我们应该怎么去判断？</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1641891619971.png" alt="" loading="lazy"></figure>
<h1 id="题目">题目</h1>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>示例 1：<br>
 <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="" loading="lazy"></p>
<p>输入：root = [3,9,20,null,null,15,7]<br>
输出：true<br>
示例 2：<br>
 <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="" loading="lazy"></p>
<p>输入：root = [1,2,2,3,3,null,null,4,4]<br>
输出：false<br>
示例 3：</p>
<p>输入：root = []<br>
输出：true</p>
<h1 id="思路">思路</h1>
<p>题目很简单，思路也很清晰，也就是我们去看树的高度差不大于1.我们只要依据这个条件去写代码就可以了</p>
<h1 id="解题">解题</h1>
<pre><code>func isBalanced(root *TreeNode) bool {
if root == nil{
    return true
}
if (!isBalanced(root.Left)||!isBalanced(root.Right)){
    return false
}
Left := getDepath(root.Left)+1
Right := getDepath(root.Right)+1
if (abs(Left-Right)&gt;1){
    return false
}
return true
}

func getDepath(root *TreeNode)int{
    if root == nil{
        return 0
    }
    return max(getDepath(root.Left),getDepath(root.Right))+1
}
func max(left,right int)int{
    if left &gt;right{
        return left
    }
    return right
}
func abs(num int)int{
if num&lt;0{
    return -num
}
return num
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最小深度]]></title>
        <id>https://IseEkko.github.io/post/er-cha-shu-de-zui-xiao-shen-du/</id>
        <link href="https://IseEkko.github.io/post/er-cha-shu-de-zui-xiao-shen-du/">
        </link>
        <updated>2022-01-11T07:01:46.000Z</updated>
        <summary type="html"><![CDATA[<p>对于二叉树最小深度的解题相关，包含源码</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于二叉树最小深度的解题相关，包含源码</p>
<!-- more -->
<h1 id="题目">题目</h1>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<!-- more -->
<p>说明：叶子节点是指没有子节点的节点。</p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="avatar" loading="lazy"></figure>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>
输出：2<br>
示例 2：</p>
<p>输入：root = [2,null,3,null,4,null,5,null,6]<br>
输出：5</p>
<h1 id="思路">思路</h1>
<pre><code> 对于这个题目，最开始我是没有什么思路的，后面去看了解析才知道怎么写到。这里把之前看到的进行一个总结。
  这个题目的主要思想就是后序遍历，后序遍历就是对树的中间节点进行最后的操作。
</code></pre>
<h1 id="解题源码">解题源码</h1>
<pre><code>func minDepth(root *TreeNode) int {
  return getDepth(root)
}

func getDepth(root *TreeNode)int{
    if root == nil{
        return 0
    }
    left := getDepth(root.Left)
    right := getDepth(root.Right)
    if (root.Left ==nil&amp;&amp;root.Right != nil){
        return right+1
    }
    if (root.Left != nil&amp;&amp; root.Right == nil){
        return left+1
    }
    return 1+min(left,right)
}
func min(left,right int)int{
    if left&lt;right{
        return left
    }
    return right
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最大深度]]></title>
        <id>https://IseEkko.github.io/post/er-cha-shu-de-zui-da-shen-du/</id>
        <link href="https://IseEkko.github.io/post/er-cha-shu-de-zui-da-shen-du/">
        </link>
        <updated>2022-01-10T13:36:10.000Z</updated>
        <summary type="html"><![CDATA[<p>二叉树的最大深度。我们使用什么方法去破解？</p>
]]></summary>
        <content type="html"><![CDATA[<p>二叉树的最大深度。我们使用什么方法去破解？</p>
<!-- more -->
<p><img src="https://IseEkko.github.io//post-images/1641825317112.png" alt="" loading="lazy"># 题目<br>
给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>  3
/  \
</code></pre>
<p>9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3</p>
<h1 id="思考">思考</h1>
<p>拿到这个题目我们最先想到的就是层序遍历，为什么呢？<br>
我们首先要明白层序遍历我们最后的结果是什么，层序遍历我们最后得到的是一个二位数组。<br>
那我们换个角度去看他，最大的深度是不是就是层序遍历最后二维数组的层数。答案是肯定的。<br>
上面是我最先能使用的方法。</p>
<h1 id="解题">解题</h1>
<p>这里解题的方式有两种</p>
<h2 id="递归法">递归法</h2>
<p>这里我们回顾一下递归的三个要素。根据三要素来书写代码。<br>
1. 确定输入和返回值<br>
2. 确定终止条件<br>
3. 确定单层逻辑<br>
那么下面我们来详细的书写一下代码<br>
首先我们确定输入和返回值，这里我们首先输入的肯定是节点，然后返回的是深度</p>
<pre><code> function fun(){
    func getDepths(root *TreeNode) int
 }
 fun();
</code></pre>
<p>第二步是确定终止的条件，这里我们终止的条件是节点是nil<br>
if root ==nil{<br>
return 0<br>
}<br>
第三步确定单层的逻辑<br>
Left := getDepths(root.Left)<br>
Right := getDepths(root.Right)<br>
deth := 1 + max(Left,Right)<br>
这里需要注意的是，我们最后得到的是高度，这里的高度是需要加一的。</p>
<p>最后的源码：</p>
<pre><code>func maxDepth(root *TreeNode) int {
   return getDepths(root)
}

func getDepths(root *TreeNode) int{
    if root ==nil{
        return 0
    }
    Left := getDepths(root.Left)
    Right := getDepths(root.Right)
    deth := 1 + max(Left,Right)
    return deth
}

func max(Left,Right int)int{
    if Left &gt; Right{
        return Left
    }
        return Right
}
</code></pre>
<h3 id="迭代法">迭代法</h3>
<p>这个方法也就是我之前想到的那个方法，也就是使用层讯遍历去完成这个题目，这里我们就不在过多的解析<br>
在后面的层序遍历的地方我会把这段代码详细的解析一遍。</p>
<pre><code>func maxDepth(root *TreeNode) int {
    var res [][]int
    if root == nil{
        return 0
    }
    st:= list.New()
    st.PushBack(root)
    var Arrtem []int
    for st.Len() &gt; 0{
        lenth := st.Len()
        for i := 0;i&lt;lenth;i++{
            node := st.Remove(st.Front()).(*TreeNode)
            if node.Left != nil{
                st.PushBack(node.Left)
            }
            if node.Right != nil{
                st.PushBack(node.Right)
            }
            Arrtem = append(Arrtem,node.Val)
        }
        res  = append(res,Arrtem)
        Arrtem = []int{}
    }
    result := len(res)
  return result
}

</code></pre>
]]></content>
    </entry>
</feed>