<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>BytesLzz</title>
    <updated>2022-04-09T03:29:25.597Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>做好每一件事，读好每一本书，天道酬勤</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, BytesLzz</rights>
    <entry>
        <title type="html"><![CDATA[错误异常机制]]></title>
        <id>https://IseEkko.github.io/post/cuo-wu-yi-chang-ji-zhi/</id>
        <link href="https://IseEkko.github.io/post/cuo-wu-yi-chang-ji-zhi/">
        </link>
        <updated>2022-04-09T03:12:07.000Z</updated>
        <summary type="html"><![CDATA[<p>在编写程序的时候很容易遇见的一个问题，也是必须要处理的，今天简单的去了解了一下什么是错误什么是异常，在go中是如何处理的</p>
]]></summary>
        <content type="html"><![CDATA[<p>在编写程序的时候很容易遇见的一个问题，也是必须要处理的，今天简单的去了解了一下什么是错误什么是异常，在go中是如何处理的</p>
<!-- more -->
<h2 id="错误异常">错误异常</h2>
<p>在了解怎么做之前，我们首先应该要明白，什么是错误，什么是异常</p>
<ul>
<li>错误：可以预测</li>
<li>异常：不可预测<br>
在程序的编码中，我们写的代码有时候我们知道他可能会出现什么错，那么我们就叫做错误，比如说我们写的这个代码：</li>
</ul>
<pre><code>func pan(i int) {
	if i == 0 {
		err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
		panic(err)
	}
}
</code></pre>
<p>如果我们用这个判断除数的话，那么可以知道除数是不能为0的，如果出现了除数为0那么他肯定是错误的，这种可以预测的，我们称之为错误。其他的错误是我们没有预测那么那些错误就是异常。感觉说的有点小绕。<br>
其实简单的就是，预测的叫做错误没有预测的就是异常。</p>
<h2 id="如何进行处理">如何进行处理</h2>
<p>在go中如果我们执行了panic，我们会得到下面这种结构。首先我们来看一下我们执行的代码：</p>
<pre><code>func main() {
  pan(0)
  fmt.Println(&quot;main安全退出&quot;)
}
func pan(i int) {

  if i == 0 {
  	err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
  	panic(err)
  }
}
</code></pre>
<p>这里我们输入了0，那么肯定是会执行panic函数的，那么执行了panic函数过后程序就会直接被终止，所以我们会得到下面这个结果。</p>
<pre><code>/private/var/folders/55/2cf9m54s36q_1yf2j1svkf580000gn/T/GoLand/___go_build_awesomeProject1_2022_4_9_PanicAndRecover
panic: i 不能为 0 %!(EXTRA time.Time=2022-04-09 11:19:17.141969 +0800 CST m=+0.000072167)

goroutine 1 [running]:
main.pan(0x0)
        /Users/lizhongzheng/GolandProjects/awesomeProject1/2022-4-9/PanicAndRecover/main.go:16 +0xd0
main.main()
        /Users/lizhongzheng/GolandProjects/awesomeProject1/2022-4-9/PanicAndRecover/main.go:9 +0x24
</code></pre>
<p>这里会清楚的写到在那里执行执行了panic，然后panic的错误是什么等相关信息。<br>
但是我们这里就会产生一个疑问，如果我们的程序正在运行但是不想让这个Panic将我们的程序直接终止，我们应该怎么处理。我们看到这里的结果是直接终止了程序的执行，最后是没有回到主函数执行输出的。<br>
对着这种处理，在php和java中使用有try catch这个方法进行处理，但是在go中是没有的，那么应该如果进行类似的处理呢？<br>
这里我们就要使用到一个recover()函数了，这个函数和panic一般都是一起出现的，这个函数的作用就是处理panic报的错误，然后收集不让程序直接退出。<br>
这里我们来演示一下有recover这个函数后，程序的执行吧，还是先上我们执行的源码：</p>
<pre><code>func main() {
	pan(0)
	fmt.Println(&quot;main安全退出&quot;)
}
func pan(i int) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(&quot;检测到错误&quot;, err)
		} else {
			panic(&quot;检测失败&quot;)
		}
	}()
	if i == 0 {
		err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
		panic(err)
	}
}
</code></pre>
<p>这个我们使用的defer，延迟处理函数，然后在这里return前进行一个调用，对于defer函数在以后我们再进行讲解，在这里我们知道它是延迟处理就可以了。<br>
然后下面是我们的执行结果：</p>
<pre><code>/private/var/folders/55/2cf9m54s36q_1yf2j1svkf580000gn/T/GoLand/___go_build_awesomeProject1_2022_4_9_PanicAndRecover
检测到错误 i 不能为 0 %!(EXTRA time.Time=2022-04-09 11:27:48.221554 +0800 CST m=+0.000130459)
&lt;!-- more --&gt;

main安全退出
</code></pre>
<p>不错我们执行到了最后，main函数安全退出，我们就演示到这里了，这就是go处理错误和异常的方法了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go_context（1）]]></title>
        <id>https://IseEkko.github.io/post/go_context-xue-xi-1/</id>
        <link href="https://IseEkko.github.io/post/go_context-xue-xi-1/">
        </link>
        <updated>2022-04-08T08:25:53.000Z</updated>
        <summary type="html"><![CDATA[<p>一直对context这个东西保持一个神秘感，今天对这部分内容进行了一个查看，可能理解不是很到位。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一直对context这个东西保持一个神秘感，今天对这部分内容进行了一个查看，可能理解不是很到位。</p>
<!-- more -->
<h2 id="context是什么">context是什么</h2>
<p>首先对于context这个东西到底是什么，在之前我的学长们总是给说什么上下文，但是呢我总是不理解这个东西，上下文？？？一脸的问号，什么是上下文？<br>
在我们交流的语言中呢，比如英语这个玩意（我贼垃圾），比如一个单词在这里是这个意思，但是换个地方他就不是那个意思了，，，emm也不知道大家理解没有，大概就是这个意思。<br>
然后官方一点的回答，什么是context。这个东西是怎么产生的。<br>
其实这个东西是在go1.17的时候加入的官方库的，具体的产生和go的并发是有关系的，在go的编程中最重要的东西就是channel和goroutine这两个玩意。在我们写go程序的时候，我们需要调用函数，在调用的时候很有可能我们会开启一连串的goroutine，那么我们怎么来达到一个特殊数据的一些传递和对goroutine的关闭呢？通过信号量这个玩意，使用sync.Wait来对它进行一个信号量的管理，其实这样肯定是不好的。所以我们的contxet就诞生了。</p>
<pre><code>简单的来说：context的作用就是在不同的goroutine之间进行同步，请求特定的数据取消信号量以及处理请求的截止时间。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1649408733993.png" alt="" loading="lazy"></figure>
<h2 id="context的使用">context的使用</h2>
<p>现在我们来看一下这个玩意我们应该怎么使用</p>
<h3 id="context创建">Context创建</h3>
<p>要想使用那么第一步肯定就是对这个东西的创建。<br>
context包主要提供了两种方式创建context:</p>
<ul>
<li>context.Backgroud()</li>
<li>context.TODO()</li>
<li>这两个函数其实只是互为别名，没有差别，官方给的定义是：<br>
context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来。<br>
context.TODO 应该只在不确定应该使用哪种上下文时使用；<br>
所以在大多数情况下，我们都使用context.Background作为起始的上下文向下传递。<br>
我们可以查看一下这部分的源码：<br>
<img src="https://IseEkko.github.io//post-images/1649407256932.png" alt="" loading="lazy"><br>
我们可以很清楚的看见，这两个最后返回的东西其实是一样的。</li>
</ul>
<h3 id="四个重要的函数">四个重要的函数</h3>
<p>我们创建过后，我们可以看到他可以调用的四个重要函数</p>
<pre><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
</code></pre>
<p>这里我们看到了这个四个重要的函数，这里我们简单的说一下它是干什么用的，后面我再对四个函数进行一个详细的学习和总结</p>
<h3 id="withvalue携带数据">WithValue携带数据</h3>
<h3 id="withtimeout超时控制">WithTimeout超时控制</h3>
<h3 id="withcancel取消控制">withCancel取消控制</h3>
<h3 id="withdeadline就是对withcancel取消控制的调用">WithDeadline就是对withCancel取消控制的调用</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三数之和]]></title>
        <id>https://IseEkko.github.io/post/san-shu-zhi-he/</id>
        <link href="https://IseEkko.github.io/post/san-shu-zhi-he/">
        </link>
        <updated>2022-04-08T05:17:18.000Z</updated>
        <content type="html"><![CDATA[<p>三数之和，这个题目做过了很多次但是还是有点不清楚，今天重新做了一下。</p>
<h2 id="题目解析">题目解析</h2>
<p>这个题目理解起来还是很简单的，也就是在一个数组里面我们将三个数字加起来等于0那么记录一下就可以了，所以最后的输出肯定是一个二维数组。首先我们要做的事情就是找出来这些数字。<br>
这里我们使用迭代的方式，我们首先将数组进行排序，然后使用双指针的方式将数字找出来，首先我们先取出一个数字，然后我们就将一个三个数字的题目转换成一个两个数字的题目。<br>
然后我们在找两个数字的时候，因为我们的数组是进行了排序的，所以我们就将情况分解出来，也就是说如果最后三个数字的和大于零那么就是说明右边界太大了，那么我们就调整右边界，同理我们可以调整左边界。<br>
这里需要注意一个点，也就是我们在最后的结构，我们不要重复的，所以相同的数字我们就要将它排除，这里我们有三段代码做了这件事情。</p>
<h2 id="解题源码">解题源码</h2>
<pre><code>func threeSum(nums []int) [][]int {
  sort.Ints(nums)
  return TreeNum(nums)
}


func TreeNum(nums []int)[][]int{
   res := make([][]int,0)
   for i := 0;i&lt;len(nums)-2;i++{
       n1 := nums[i]
       if n1 &gt; 0{
           break
       }
       if i &gt; 0 &amp;&amp; n1 == nums[i-1]{
           continue
       }

       l,r := i+1,len(nums)-1
       for l &lt; r{
                n2 ,n3 := nums[l],nums[r]
                if n1+n2+n3 == 0 {
                    res = append(res,[]int{n1,n2,n3})
                    for l&lt;r &amp;&amp; nums[l] == n2{
                        l++
                    }
                    for l&lt;r &amp;&amp; nums[r] == n3{
                        r--
                    }
                }else if n1+n2+n3 &lt; 0{
                    l++
                }else{
                    r--
                }
       }
   }
   return res
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语言并发-订阅者模式]]></title>
        <id>https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/">
        </link>
        <updated>2022-04-07T07:44:39.000Z</updated>
        <content type="html"><![CDATA[<p>在之前的学习中，接触到了消息队列的一些知识，然后今天在看书的时候，发现了一个使用go channel完成了一个订阅者模式的并发demo。</p>
<h2 id="订阅者模式">订阅者模式</h2>
<p>关于订阅者模式，在这里给大家讲解一下，订阅者模式其实就是将产生的消息，给多个订阅者，然后订阅者可以看到这里订阅的消息。<br>
这里实现的时候呢，因为有并发的知识，所以我们用到了协程，下面我们来具体的实现一下。</p>
<h2 id="具体的实现流程">具体的实现流程</h2>
<h3 id="创建订阅者结构">创建订阅者结构</h3>
<pre><code>type (
	subscriber chan interface{}         //订阅者的通道
	topicFunc  func(v interface{}) bool //主题过滤器
)

//发布者对象
type Publisher struct {
	m           sync.Mutex               //读写锁
	buffer      int                      //订阅队列缓存大小
	timeout     time.Duration            //发布者超时时间
	subscribers map[subscriber]topicFunc //订阅者消息
}
</code></pre>
<p>上面我们定义了基本的订阅者的结构，上面也有对订阅者字段的解释，这里着重理解的东西就是：</p>
<pre><code>subscribers map[subscriber]topicFunc //订阅者消息
</code></pre>
<p>这个结构其实就是订阅者模式的一个重要的结构，这里存放的是订阅者的过滤器，也就是通过这个结构我们可以清楚的知道，订阅者订阅的是那个主题。</p>
<h3 id="构造函数">构造函数</h3>
<p>使用构造函数构造出订阅者的实体，然后进行后面的操作</p>
<pre><code>func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		buffer:      buffer,
		timeout:     publishTimeout,
		subscribers: make(map[subscriber]topicFunc),
	}
}
</code></pre>
<h3 id="添加订阅者信息">添加订阅者信息</h3>
<pre><code>//订阅全部，也就是不加入过滤器
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

//添加一个订阅者，同时订阅者是有过滤器的
//这里其实就是返回一个订阅者的信息，然后添加上过滤器
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}
</code></pre>
<p>这里就是添加订阅者，这里添加的时候添加订阅者的过滤器，也就是增加一个映射关系。</p>
<h3 id="添加主题">添加主题</h3>
<pre><code>//发布一个主题
func (p *Publisher) Publish(v interface{}) {
	p.m.Lock()
	defer p.m.Unlock()
	var wg sync.WaitGroup
	//这里返回的是订阅者，然后后面是返回的过滤器
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.sendTopic(sub, topic, v, &amp;wg)
	}
	wg.Wait()
}

//发布主题，可以容忍一定的超时
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}
	select {
	case sub &lt;- v:
	case &lt;-time.After(p.timeout):
	}
}
</code></pre>
<p>这里我们使用到的并发式的添加消息，这里使用到了sync.WaitGroup，进行协程的同步。</p>
<h3 id="关闭订阅者模式">关闭订阅者模式</h3>
<pre><code>//关闭发布对象，同时关闭
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()
	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}
</code></pre>
<h2 id="最后的测试">最后的测试</h2>
<pre><code>func main() {
	p := NewPublisher(100*time.Millisecond, 10)
	defer p.Close()
	all := p.Subscribe()
	golang := p.SubscribeTopic(func(v interface{}) bool {
		if s, ok := v.(string); ok {
			return strings.Contains(s, &quot;golang&quot;)
		}
		return false
	})
	p.Publish(&quot;hello,lzz&quot;)
	p.Publish(&quot;hello,golang&quot;)
	go func() {
		for msg := range all {
			fmt.Println(&quot;all:&quot;, msg)
		}
	}()
	go func() {
		for msg := range golang {
			fmt.Println(&quot;golang:&quot;, msg)
		}
	}()
	time.Sleep(3 * time.Second)
}
</code></pre>
<p>最后的输出结果：<br>
<img src="https://IseEkko.github.io//post-images/1649321380937.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打印齿形的二叉树层序遍历]]></title>
        <id>https://IseEkko.github.io/post/da-yin-chi-xing-de-er-cha-shu-ceng-xu-bian-li/</id>
        <link href="https://IseEkko.github.io/post/da-yin-chi-xing-de-er-cha-shu-ceng-xu-bian-li/">
        </link>
        <updated>2022-04-06T15:16:26.000Z</updated>
        <content type="html"><![CDATA[<p>层序遍历是一个很常见的一个算法结构，这里我们进一步的进行二叉树的学习，这里需要蛇形的打印出二叉树的层序遍历</p>
<h2 id="题目解析">题目解析</h2>
<p>这里题目很简单，就是打印的顺序和上一层的顺序是相反的，也就是说单数层和双数层的打印顺序是相反的，那么就是说我们在打印不同层的时候，我们打印的顺序是不一样的，也就是说在之前层序的基础上，我们这里要判断一下层数的判断。<br>
我们这里的代码使用的切片来进行数据的处理，这里我们还要注意的事情是我们在不同层打印顺序问题，使用到的是将顺序进行交换，就是在判断层数的基础上，我们将需要交换的位置进行交换。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1649258272528.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一致性hash算法]]></title>
        <id>https://IseEkko.github.io/post/yi-zhi-xing-hash-suan-fa/</id>
        <link href="https://IseEkko.github.io/post/yi-zhi-xing-hash-suan-fa/">
        </link>
        <updated>2022-04-04T08:57:04.000Z</updated>
        <content type="html"><![CDATA[<p>分布式缓存中的运用。</p>
<h2 id="分布式缓存">分布式缓存</h2>
<p>在我们的分布式应用中我们常常会用到分布式缓存，什么是分布式缓存，说简单点就是将缓存放在几台机器上，然后我们就会发现一个问题，我们怎么做到用户想要数据的时候将数据给到用户呢。</p>
<h2 id="一般的hash算法">一般的hash算法</h2>
<p>使用一般的hash算法呢，就是将值进行hash然后取余服务器的数量，然后就会得到数字，然后将数据放在对应编号的服务器中。<br>
但是这样的话，容错性和扩展性都很差，为什么呢？<br>
无论是多了一台机器还是少一台机器它的hash后取余的位置都会不一样，然后访问数据的时候，因为服务器数量的变化这里也是不一样的。也就是说如果出现宕机或者想要增加服务器，那么所有的缓存都会失效。<br>
为了避免这样的问题产生，我们就要使用到hash一致性算法</p>
<h2 id="hash一致性算法">hash一致性算法</h2>
<p>hash一致性算法，在hash一致性算法中，我们首先先生成一个2^32的圆，然后将服务器节点进行hash放在圆上，然后将数据进行hash，然后hash到的位置，我们进行顺时针的寻找，寻找到第一个节点，我们就会将数据存放在上面，然后这里我们需要注意的事情是，这里我们需要增加虚拟节点，因为在hash的时候我们的服务器节点不一定说就是均匀分布的，这个时候如果节点很少，可能就会发生一些数据的偏移，可能会出现大部分的数据存放在一个服务器上，然后这个时候对于这个服务器来说，这样的压力就会很大，所以我们通过将节点进行增加几个虚拟节点来解决这个问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组内部实现和基本使用]]></title>
        <id>https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/</id>
        <link href="https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/">
        </link>
        <updated>2022-03-24T11:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>了解go数组的细节</p>
<h2 id="数组的内部实现和基础功能">数组的内部实现和基础功能</h2>
<p>在go中数组是一个长度固定的数据类型，用于存储具有相同类型的元素的连续块。因为存储的空间是连续的，所以遍历和查找元素也是很方便和简单的。</p>
<h3 id="声明和初始化">声明和初始化</h3>
<p>一旦声明了数组的长度和数组类型那么久不能在改变了，在go中数组的长度和类型也是类型的判断属性。只有两个属性相同的时候才能判定这个两个数组相同。</p>
<h3 id="初始化">初始化</h3>
<p>第一种：声明一个数组，并设置为零值<br>
var array [5]int<br>
第二种：使用数组字面量声明数组<br>
array := [5]int{1,2,3,4,5}<br>
第三种：让go自动计算声明数组长度<br>
array ：= […]int{1,2,3,4,5}<br>
第四种：声明数组并指定特定元素的值<br>
array  := [5]int{1:10,2:20}</p>
<h2 id="使用数组">使用数组</h2>
<p>因为数组的地址空间是连续的，所以数组的效率是很高的。如果要访问数组中的某个元素，使用【】加上下标就可以进行访问。<br>
使用指针类型的数组的时候，里面存放的是地址。把一个指针数组赋值给另一个指针数组，这个时候这两个数组中存放的地址是相同的，也就是指向的同一个地址空间。</p>
<h2 id="多维数组">多维数组</h2>
<p>数组本身只有一个纬度，不过可以组合多个数组创建多位数组。这里就不再多说多位数组的相关知识了。</p>
<h2 id="在函数间传递数组">在函数间传递数组</h2>
<p>在go中传递一个值，都是以类型的方式进行传输的，也就是说传递一个数组，会复制一个完整的数组进行传输，也就是说无论数组多大我们都会进行数组的全复制然后进行传输。<br>
这样的话我们就会损失效率，我们解决的办法就是使用指针类型进行传输。这个时候传输复制的时候就只用复制8字节的指针类型了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NAT地址转换]]></title>
        <id>https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/</id>
        <link href="https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/">
        </link>
        <updated>2022-03-24T00:08:35.000Z</updated>
        <content type="html"><![CDATA[<p>NAT地址转换它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。<br>
实现的三种方法</p>
<h2 id="三种实现方法有利有弊">三种实现方法有利有弊</h2>
<h3 id="第一种">第一种</h3>
<p>静态地址转换，内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可网络对内部网以实现外部络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p>
<h3 id="第二种">第二种</h3>
<p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p>
<h3 id="第三种">第三种</h3>
<p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARP协议]]></title>
        <id>https://IseEkko.github.io/post/arp-xie-yi/</id>
        <link href="https://IseEkko.github.io/post/arp-xie-yi/">
        </link>
        <updated>2022-03-24T00:08:05.000Z</updated>
        <content type="html"><![CDATA[<p>ARP协议是一个mac地址和IP地址的一个映射关系，也就是系统通过ip找到他的mac地址。<br>
过程</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿数量]]></title>
        <id>https://IseEkko.github.io/post/dao-yu-shu-liang/</id>
        <link href="https://IseEkko.github.io/post/dao-yu-shu-liang/">
        </link>
        <updated>2022-03-22T15:09:58.000Z</updated>
        <content type="html"><![CDATA[<p>今天做了一个题目就是关于一个二维数组。</p>
<h2 id="题目解析">题目解析</h2>
<p>在这个题目里面，我们需要做的是判断岛的数量，在这里1表示的是岛屿，0表示的是海洋，相邻的1表示的是一个岛屿。然后看到这里，我们就想到了我们要使用的方法，就是遍历然后计算1的位置。<br>
如何判断相邻的1是一个岛屿，使用的就是dfs广度优先算法。</p>
<h2 id="解析源码">解析源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647961967703.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>