<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>BytesLzz</title>
    <updated>2022-04-18T07:45:17.333Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>做好每一件事，读好每一本书，天道酬勤</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, BytesLzz</rights>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--错误处理]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-cuo-wu-chu-li/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-cuo-wu-chu-li/">
        </link>
        <updated>2022-04-18T07:23:33.000Z</updated>
        <content type="html"><![CDATA[<p>很快到了七天实现web框架的最后一天了，今天的主题是错误处理，在go语言中我们是没有像其他语言一样的处理机制了。</p>
<h2 id="错误处理">错误处理</h2>
<p>在go语言中，我们使用panic对异常进行抛出，这样会将程序直接中断，但是这样肯定是不好的。<br>
我们首先来看一下，defer的应用，对于defer函数，我们需要知道的是，defer就是将操作进行一个延迟，然后等待return前进行执行，这里是一个栈的实现方式。所以是先进后出的。<br>
然后我们还要知道的是recover的使用，这个一定要在defer之后进行使用，它的作用是将panic的错误进行一个压栈的操作，这样程序就不会直接中断，起到了一个try-catch的作用。</p>
<h2 id="具体的实现">具体的实现</h2>
<pre><code>package gee

import (
 &quot;fmt&quot;
 &quot;log&quot;
 &quot;net/http&quot;
 &quot;runtime&quot;
 &quot;strings&quot;
)

// print stack trace for debug
func trace(message string) string {
 var pcs [32]uintptr
 n := runtime.Callers(3, pcs[:]) // skip first 3 caller

 var str strings.Builder
 str.WriteString(message + &quot;\nTraceback:&quot;)
 for _, pc := range pcs[:n] {
 	fn := runtime.FuncForPC(pc)
 	file, line := fn.FileLine(pc)
 	str.WriteString(fmt.Sprintf(&quot;\n\t%s:%d&quot;, file, line))
 }
 return str.String()
}

func Recovery() HandlerFunc {
 return func(c *Context) {
 	defer func() {
 		if err := recover(); err != nil {
 			message := fmt.Sprintf(&quot;%s&quot;, err)
 			log.Printf(&quot;%s\n\n&quot;, trace(message))
 			c.Fail(http.StatusInternalServerError, &quot;Internal Server Error&quot;)
 		}
 	}()

 	c.Next()
 }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--模版渲染]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-mo-ban-xuan-ran/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-mo-ban-xuan-ran/">
        </link>
        <updated>2022-04-17T07:56:25.000Z</updated>
        <content type="html"><![CDATA[<p>现在流行的前后端分离项目，使用更加专业的前端框架来制作页面，使用ajax进行数据交互，这样使得页面更加的专业。<br>
但是前后端分离的项目，还是很有缺点的，所以对于模版渲染这个功能还是要有的。</p>
<h2 id="模版渲染的实现">模版渲染的实现</h2>
<p>网页的三剑客，JavaScript、CSS 和 HTML。要做到服务端渲染，第一步便是要支持 JS、CSS 等静态文件。还记得我们之前设计动态路由的时候，支持通配符*匹配多级子路径。比如路由规则/assets/*filepath，可以匹配/assets/开头的所有的地址。例如/assets/js/geektutu.js，匹配后，参数filepath就赋值为js/geektutu.js。<br>
那如果我么将所有的静态文件放在/usr/web目录下，那么filepath的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。<br>
找到文件后，如何返回这一步，net/http库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给http.FileServer处理就好了。</p>
<pre><code>// create static handler
func (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc {
	absolutePath := path.Join(group.prefix, relativePath)
	fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))
	return func(c *Context) {
		file := c.Param(&quot;filepath&quot;)
		// Check if file exists and/or if we have permission to access it
		if _, err := fs.Open(file); err != nil {
			c.Status(http.StatusNotFound)
			return
		}

		fileServer.ServeHTTP(c.Writer, c.Req)
	}
}

// serve static files
func (group *RouterGroup) Static(relativePath string, root string) {
	handler := group.createStaticHandler(relativePath, http.Dir(root))
	urlPattern := path.Join(relativePath, &quot;/*filepath&quot;)
	// Register GET handlers
	group.GET(urlPattern, handler)
}
</code></pre>
<p>我们给RouterGroup添加了2个方法，Static这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹root映射到路由relativePath。例如：</p>
<pre><code>r := gee.New()
r.Static(&quot;/assets&quot;, &quot;/usr/geektutu/blog/static&quot;)
// 或相对路径 r.Static(&quot;/assets&quot;, &quot;./static&quot;)
r.Run(&quot;:9999&quot;)
用户访问localhost:9999/assets/js/geektutu.js，最终返回/usr/geektutu/blog/static/js/geektutu.js。
</code></pre>
<h2 id="html-模板渲染">HTML 模板渲染</h2>
<p>Go语言内置了text/template和html/template2个模板标准库，其中html/template为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee 框架的模板渲染直接使用了html/template提供的能力。</p>
<pre><code>Engine struct {
	*RouterGroup
	router        *router
	groups        []*RouterGroup     // store all groups
	htmlTemplates *template.Template // for html render
	funcMap       template.FuncMap   // for html render
}

func (engine *Engine) SetFuncMap(funcMap template.FuncMap) {
	engine.funcMap = funcMap
}

func (engine *Engine) LoadHTMLGlob(pattern string) {
	engine.htmlTemplates = template.Must(template.New(&quot;&quot;).Funcs(engine.funcMap).ParseGlob(pattern))
}
</code></pre>
<p>首先为 Engine 示例添加了 *template.Template 和 template.FuncMap对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>
<p>另外，给用户分别提供了设置自定义渲染函数funcMap和加载模板的方法。</p>
<p>接下来，对原来的 (*Context).HTML()方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>
<pre><code>type Context struct {
    // ...
	// engine pointer
	engine *Engine
}

func (c *Context) HTML(code int, name string, data interface{}) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;text/html&quot;)
	c.Status(code)
	if err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != nil {
		c.Fail(500, err.Error())
	}
}
</code></pre>
<p>我们在 Context 中添加了成员变量 engine *Engine，这样就能够通过 Context 访问 Engine 中的 HTML 模板。实例化 Context 时，还需要给 c.engine 赋值。</p>
<pre><code>func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	// ...
	c := newContext(w, req)
	c.handlers = middlewares
	c.engine = engine
	engine.router.handle(c)
}
</code></pre>
<p>使用Demo<br>
最终的目录结构<br>
---gee/<br>
---static/<br>
|---css/<br>
|---geektutu.css<br>
|---file1.txt<br>
---templates/<br>
|---arr.tmpl<br>
|---css.tmpl<br>
|---custom_func.tmpl<br>
---main.go</p>
<pre><code>&lt;!-- day6-template/templates/css.tmpl --&gt;
&lt;html&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/css/geektutu.css&quot;&gt;
    &lt;p&gt;geektutu.css is loaded&lt;/p&gt;
&lt;/html&gt;
day6-template/main.go
</code></pre>
<pre><code>type student struct {
	Name string
	Age  int8
}

func FormatAsDate(t time.Time) string {
	year, month, day := t.Date()
	return fmt.Sprintf(&quot;%d-%02d-%02d&quot;, year, month, day)
}

func main() {
	r := gee.New()
	r.Use(gee.Logger())
	r.SetFuncMap(template.FuncMap{
		&quot;FormatAsDate&quot;: FormatAsDate,
	})
	r.LoadHTMLGlob(&quot;templates/*&quot;)
	r.Static(&quot;/assets&quot;, &quot;./static&quot;)

	stu1 := &amp;student{Name: &quot;Geektutu&quot;, Age: 20}
	stu2 := &amp;student{Name: &quot;Jack&quot;, Age: 22}
	r.GET(&quot;/&quot;, func(c *gee.Context) {
		c.HTML(http.StatusOK, &quot;css.tmpl&quot;, nil)
	})
	r.GET(&quot;/students&quot;, func(c *gee.Context) {
		c.HTML(http.StatusOK, &quot;arr.tmpl&quot;, gee.H{
			&quot;title&quot;:  &quot;gee&quot;,
			&quot;stuArr&quot;: [2]*student{stu1, stu2},
		})
	})

	r.GET(&quot;/date&quot;, func(c *gee.Context) {
		c.HTML(http.StatusOK, &quot;custom_func.tmpl&quot;, gee.H{
			&quot;title&quot;: &quot;gee&quot;,
			&quot;now&quot;:   time.Date(2019, 8, 17, 0, 0, 0, 0, time.UTC),
		})
	})

	r.Run(&quot;:9999&quot;)
}
</code></pre>
<p>访问下主页，模板正常渲染，CSS 静态文件加载成功。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--中间件的实现]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-zhong-jian-jian-de-shi-xian/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-zhong-jian-jian-de-shi-xian/">
        </link>
        <updated>2022-04-16T15:58:36.000Z</updated>
        <content type="html"><![CDATA[<p>在web开发中，我们需要在真正的逻辑处理前，我们有些操作需要提前进行处理，同时逻辑处理后，我们需要处理其他的逻辑。</p>
<h2 id="什么是中间件">什么是中间件</h2>
<p>在正式的业务逻辑处理前或之后，我们需要进行一些处理。这些处理是需要我们添加中间件来进行添加的。因为在框架中，我们需要给用户自己添加一些处理方式函数的地方的，这个地方呢我们不能太过于底层，这样对于用户来说肯定是不好的。<br>
所以我们需要一个比较好的方式进行添加。</p>
<h2 id="实现思路">实现思路</h2>
<p>对于这个中间件的添加，逻辑我们也是很简单的，我们使用一个切片进行存储函数来实现，首先是需要在路由中进行存储的，然后我们将这个东西放在上下文中去进行存储。</p>
<pre><code>type RouterGroup struct {
	prefix      string
	middlewares []HandlerFunc // support middleware
	parent      *RouterGroup  // support nesting
	engine      *Engine       // all groups share a Engine instance
}
</code></pre>
<p>上下文中的存储</p>
<pre><code>type Context struct {
	// origin objects
	Writer http.ResponseWriter
	Req    *http.Request
	// request info
	Path   string
	Method string
	Params map[string]string
	// response info
	StatusCode int
	// middleware
	handlers []HandlerFunc
	index    int
}

func (c *Context) Next() {
	c.index++
	s := len(c.handlers)
	for ; c.index &lt; s; c.index++ {
		c.handlers[c.index](c)
	}
}
</code></pre>
<p>为什么在路由中进行存储了我们还需要在上下文进行存储呢？<br>
我们可以看到，在这里我们还实现了一个函数，就是next，关于next函数其实就是我们将中间件分成了两个部分，一个是处理业务代码前处理，和业务代码处理后处理，那么在next前的就是业务逻辑前，然后后面就是业务逻辑后。然后这里我们做一个演示：</p>
<pre><code>func A(c *Context) {
    part1
    c.Next()
    part2
}
func B(c *Context) {
    part3
    c.Next()
    part4
}
</code></pre>
<p>我们来看一下上面这个函数的执行顺序：<br>
假设我们应用了中间件 A 和 B，和路由映射的 Handler。c.handlers是这样的[A, B, Handler]，c.index初始化为-1。调用c.Next()，接下来的流程是这样的：</p>
<p>c.index++，c.index 变为 0<br>
0 &lt; 3，调用 c.handlers[0]，即 A<br>
执行 part1，调用 c.Next()<br>
c.index++，c.index 变为 1<br>
1 &lt; 3，调用 c.handlers[1]，即 B<br>
执行 part3，调用 c.Next()<br>
c.index++，c.index 变为 2<br>
2 &lt; 3，调用 c.handlers[2]，即Handler<br>
Handler 调用完毕，返回到 B 中的 part4，执行 part4<br>
part4 执行完毕，返回到 A 中的 part2，执行 part2<br>
part2 执行完毕，结束。<br>
一句话说清楚重点，最终的顺序是part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p>
<h2 id="测试函数">测试函数</h2>
<pre><code>func onlyForV2() gee.HandlerFunc {
	return func(c *gee.Context) {
		// Start timer
		t := time.Now()
		// if a server error occurred
		c.Fail(500, &quot;Internal Server Error&quot;)
		// Calculate resolution time
		log.Printf(&quot;[%d] %s in %v for group v2&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))
	}
}

func main() {
	r := gee.New()
	r.Use(gee.Logger()) // global midlleware
	r.GET(&quot;/&quot;, func(c *gee.Context) {
		c.HTML(http.StatusOK, &quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;)
	})

	v2 := r.Group(&quot;/v2&quot;)
	v2.Use(onlyForV2()) // v2 group middleware
	{
		v2.GET(&quot;/hello/:name&quot;, func(c *gee.Context) {
			// expect /hello/geektutu
			c.String(http.StatusOK, &quot;hello %s, you're at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)
		})
	}

	r.Run(&quot;:9999&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--动态路由]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-dong-tai-lu-you/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-dong-tai-lu-you/">
        </link>
        <updated>2022-04-14T11:54:47.000Z</updated>
        <summary type="html"><![CDATA[<p>之前看学长他们用过这个动态路由，但是以前也没有太注意，最近在学习框架的建立。第一次让我感受到了算法在写项目时候的应用，之前都觉得算法这个东西，就是刷题用的，在实战的时候很少用。今天学习这一块稍微有一点吃力，但是还是看懂了，很nice。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前看学长他们用过这个动态路由，但是以前也没有太注意，最近在学习框架的建立。第一次让我感受到了算法在写项目时候的应用，之前都觉得算法这个东西，就是刷题用的，在实战的时候很少用。今天学习这一块稍微有一点吃力，但是还是看懂了，很nice。</p>
<!-- more -->
<h2 id="什么是动态路由呢">什么是动态路由呢</h2>
<p>动态路由在开发的时候，就是说不是像原来写项目的时候，这个固定路由绑定固定的函数，而是变化的路由进行固定函数的绑定，这样就可以实现很多的功能。<br>
动态路由的实例：/api/v1/:name<br>
这里我们要知道的是，上面这个路由可以匹配很多的路由比如：<br>
/api/v1/lzz     /api/v1/ceshi ....等<br>
这里第三个分隔开的字段，就是对name的赋值。这就是动态路由</p>
<h2 id="实现动态路由需要准备什么">实现动态路由需要准备什么</h2>
<p>首先我们要用到的就是前缀树，这里我们看一下怎么实现前缀树。我们还是说明一下，比如说，在我们路由中我们可以通过/来分割节点，然后后面通过这些节点进行寻找正确的路由。<img src="https://IseEkko.github.io//post-images/1649937869081.jpeg" alt="" loading="lazy">、<br>
上面的这个图就是展示了前缀树。然后下面我们就来实现一下这个前缀树。<br>
首先定义前缀树的节点：</p>
<pre><code>type node struct {
  pattern  string  //待匹配的路由
  part     string  //路由中的一部分
  children []*node //子节点
  isWild   bool //这里如果是*或者：开头的就是true
}
</code></pre>
<p>然后我们建立一个注册函数，一个查找函数</p>
<pre><code>func (n *node) insert(pattern string, parts []string, height int) {
	//查看是不是最后一个，是的话就返回
	if len(parts) == height {
		n.pattern = pattern
		return
	}
	//取出路径中的一部分
	part := parts[height]
	//查看现在的树中是不是有这个节点，没有的话就进行创建
	child := n.matchChild(part)
	//下面是创建的流程。也就是创建
	if child == nil {
		//如果是动态的就会设置为true
		child = &amp;node{part: part, isWild: part[0] == ':' || part[0] == '*'}
		n.children = append(n.children, child)
	}
	child.insert(pattern, parts, height+1)
}
</code></pre>
<p>查找函数：</p>
<pre><code>func (n *node) search(parts []string, height int) *node {
	if len(parts) == height || strings.HasPrefix(n.part, &quot;*&quot;) {
		if n.pattern == &quot;&quot; {
			return nil
		}
		return n
	}

	part := parts[height]
	children := n.matchChildren(part)

	for _, child := range children {
		result := child.search(parts, height+1)
		if result != nil {
			return result
		}
	}

	return nil
}
</code></pre>
<p>上面两个函数中有两个关键的函数，就是对路由的匹配，这两个函数我还是看了很久才理解，也是在学习的时候出现的问题。</p>
<pre><code>//创建节点插入的时候的判断函数
func (n *node) matchChild(part string) *node {
	for _, child := range n.children {
		if child.part == part || child.isWild {
			return child
		}
	}
	return nil
}

//查找路径
func (n *node) matchChildren(part string) []*node {
	nodes := make([]*node, 0)
	for _, child := range n.children {
		if child.part == part || child.isWild {
			nodes = append(nodes, child)
		}
	}
	return nodes
}

</code></pre>
<p>两个函数的原理都是差不多的，传入需要判断的路径一部分，然后在节点里面去寻找是否有这个节点，然后找到了就返回，没有找到就返回nil，我认为的这两个函数，第一个就是判断有没有这个节点，如果没有就返回，然后建立新的节点进行存储，如果找到了就不做操作。<br>
第二个函数，就是对没有部分的判断，然后进行一个添加。<br>
前缀树完整的代码：</p>
<pre><code>package gee

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

type node struct {
	pattern  string
	part     string
	children []*node
	isWild   bool
}

func (n *node) String() string {
	return fmt.Sprintf(&quot;node{pattern=%s, part=%s, isWild=%t}&quot;, n.pattern, n.part, n.isWild)
}

func (n *node) insert(pattern string, parts []string, height int) {
	//查看是不是最后一个，是的话就返回
	if len(parts) == height {
		n.pattern = pattern
		return
	}
	//取出路径中的一部分
	part := parts[height]
	//查看现在的树中是不是有这个节点，没有的话就进行创建
	child := n.matchChild(part)
	//下面是创建的流程。也就是创建
	if child == nil {
		//如果是动态的就会设置为true
		child = &amp;node{part: part, isWild: part[0] == ':' || part[0] == '*'}
		n.children = append(n.children, child)
	}
	child.insert(pattern, parts, height+1)
}

//路由的查找
func (n *node) search(parts []string, height int) *node {
	if len(parts) == height || strings.HasPrefix(n.part, &quot;*&quot;) {
		if n.pattern == &quot;&quot; {
			return nil
		}
		return n
	}

	part := parts[height]
	children := n.matchChildren(part)

	for _, child := range children {
		result := child.search(parts, height+1)
		if result != nil {
			return result
		}
	}

	return nil
}

func (n *node) travel(list *([]*node)) {
	if n.pattern != &quot;&quot; {
		*list = append(*list, n)
	}
	for _, child := range n.children {
		child.travel(list)
	}
}

//创建节点插入的时候的判断函数
func (n *node) matchChild(part string) *node {
	for _, child := range n.children {
		if child.part == part || child.isWild {
			return child
		}
	}
	return nil
}

//查找路径
func (n *node) matchChildren(part string) []*node {
	nodes := make([]*node, 0)
	for _, child := range n.children {
		if child.part == part || child.isWild {
			nodes = append(nodes, child)
		}
	}
	return nodes
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--上下文建立]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-shang-xia-wen-jian-li/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-shang-xia-wen-jian-li/">
        </link>
        <updated>2022-04-13T06:52:28.000Z</updated>
        <summary type="html"><![CDATA[<p>对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter</p>
]]></summary>
        <content type="html"><![CDATA[<p>对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter</p>
<!-- more -->
<h2 id="上下文必要性">上下文必要性</h2>
<p>在书写web应用的时候，我们使用原始的库的时候，其中接受请求信息和返回的消息体是单独的存在，然后这样就会导致我们书写很多冗余的代码，然后在返回的时候我们需要返回json这个时候如果使用原生的库这个时候我们书写的代码是：</p>
<pre><code>obj = map[string]interface{}{
 &quot;name&quot;: &quot;geektutu&quot;,
 &quot;password&quot;: &quot;1234&quot;,
}
w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
w.WriteHeader(http.StatusOK)
encoder := json.NewEncoder(w)
if err := encoder.Encode(obj); err != nil {
 http.Error(w, err.Error(), 500)
}
</code></pre>
<p>然后如果我们封装了过后我们书写的代码是：</p>
<pre><code>c.JSON(http.StatusOK, gee.H{
    &quot;username&quot;: c.PostForm(&quot;username&quot;),
    &quot;password&quot;: c.PostForm(&quot;password&quot;),
})
</code></pre>
<p>这里我们可以明显的感受到我们的代码简单了很多，如果没有进行封装，这个时候我们使用起来是非常难受的。在这里我们需要知道的是，其实在web应用中，我们需要很多的工具，在处理请求的时候，例如，将来解析动态路由/hello/:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。<br>
也就是在这次会话的时候context就是一个会话的百宝箱，这个时候我们可以找到我们处理这次会话的所有工具。</p>
<h2 id="实现代码">实现代码</h2>
<pre><code>type H map[string]interface{}

type Context struct {
	// origin objects
	Writer http.ResponseWriter
	Req    *http.Request
	// request info
	Path   string
	Method string
	// response info
	StatusCode int
}

func newContext(w http.ResponseWriter, req *http.Request) *Context {
	return &amp;Context{
		Writer: w,
		Req:    req,
		Path:   req.URL.Path,
		Method: req.Method,
	}
}

func (c *Context) PostForm(key string) string {
	return c.Req.FormValue(key)
}

func (c *Context) Query(key string) string {
	return c.Req.URL.Query().Get(key)
}

func (c *Context) Status(code int) {
	c.StatusCode = code
	c.Writer.WriteHeader(code)
}

func (c *Context) SetHeader(key string, value string) {
	c.Writer.Header().Set(key, value)
}

func (c *Context) String(code int, format string, values ...interface{}) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;)
	c.Status(code)
	c.Writer.Write([]byte(fmt.Sprintf(format, values...)))
}

func (c *Context) JSON(code int, obj interface{}) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)
	c.Status(code)
	encoder := json.NewEncoder(c.Writer)
	if err := encoder.Encode(obj); err != nil {
		http.Error(c.Writer, err.Error(), 500)
	}
}

func (c *Context) Data(code int, data []byte) {
	c.Status(code)
	c.Writer.Write(data)
}

func (c *Context) HTML(code int, html string) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;text/html&quot;)
	c.Status(code)
	c.Writer.Write([]byte(html))
}
</code></pre>
<p>在这里面我们将很多的工具进行了封装<br>
代码最开头，给map[string]interface{}起了一个别名gee.H，构建JSON数据时，显得更简洁。<br>
Context目前只包含了http.ResponseWriter和*http.Request，另外提供了对 Method 和 Path 这两个常用属性的直接访问。<br>
提供了访问Query和PostForm参数的方法。<br>
提供了快速构造String/Data/JSON/HTML响应的方法。</p>
<h2 id="对处理函数的改装">对处理函数的改装</h2>
<p>昨天我们进行了路由解析的书写，我们知道了继承了handler后我们就可以进行请求的处理，然后我们将处理的函数进行一个改装</p>
<pre><code>package gee

import (
	&quot;log&quot;
	&quot;net/http&quot;
)

type router struct {
	handlers map[string]HandlerFunc
}

func newRouter() *router {
	return &amp;router{handlers: make(map[string]HandlerFunc)}
}

func (r *router) addRoute(method string, pattern string, handler HandlerFunc) {
	log.Printf(&quot;Route %4s - %s&quot;, method, pattern)
	key := method + &quot;-&quot; + pattern
	r.handlers[key] = handler
}

func (r *router) handle(c *Context) {
	key := c.Method + &quot;-&quot; + c.Path
	if handler, ok := r.handlers[key]; ok {
		handler(c)
	} else {
		c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)
	}
}
</code></pre>
<p>我们将增加处理函数的方法放在了这里，然后对昨天的代码进行一个改装</p>
<pre><code>package gee

import (
	&quot;net/http&quot;
)

// HandlerFunc defines the request handler used by gee
type HandlerFunc func(*Context)

// Engine implement the interface of ServeHTTP
type Engine struct {
	router *router
}

// New is the constructor of gee.Engine
//这里进行了router的创建
func New() *Engine {
	return &amp;Engine{router: newRouter()}
}

func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) {
	engine.router.addRoute(method, pattern, handler)
}

// GET defines the method to add GET request
func (engine *Engine) GET(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;GET&quot;, pattern, handler)
}

// POST defines the method to add POST request
func (engine *Engine) POST(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;POST&quot;, pattern, handler)
}

// Run defines the method to start a http server
func (engine *Engine) Run(addr string) (err error) {
	return http.ListenAndServe(addr, engine)
}

//这里就是最后的处理函数，这里开始建立的上下文。
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	c := newContext(w, req)
	engine.router.handle(c)
}
</code></pre>
<p>在这里我们结合了今天写的context进行了一个改装。 然后我们今天的上下文建立就建立好了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--路由映射]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-lu-you-ying-she/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-lu-you-ying-she/">
        </link>
        <updated>2022-04-12T14:21:46.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在学习一个七天系列课程，然后在这里对自己学习到的东西进行一个总结。今天实现的是web框架中的路由映射。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在学习一个七天系列课程，然后在这里对自己学习到的东西进行一个总结。今天实现的是web框架中的路由映射。</p>
<!-- more -->
<h2 id="http-net包">Http-Net包</h2>
<p>在实现这个路由解析器的时候，我们首先要明白go原本的http/net包是如何实现路由解析定向的。<br>
其中重要的函数</p>
<pre><code>// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
 DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre>
<p>这里的函数参数，第一个是路径的函数，第二个是处理函数handle，这个函数最后调用的其实就是</p>
<pre><code>// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
</code></pre>
<p>也就是说实现了handler的接口，那么就有了处理请求的能力。那么我们来看实现handler这个接口的条件是什么。这里肤浅的解释一下这个go接口的实现，在go语言中是支持鸭子类型的，所以我们只要实现了接口里面的方法，那么就实现了这个接口。<br>
handler接口：</p>
<pre><code>type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
<p>实现这个接口我们就有能力处理网络的请求了。但是其中我们还有东西需要我们去了解<br>
首先就是我们如何获取网络请求中的路径呢？<br>
其实这个很简单，在我们的Request中其实是包含了请求的路径的，获取的方式：<br>
req.URL.Path<br>
获取了过后我们就可以将请求的路径和对应的函数的建立起映射的关系。<br>
在这里我们简单的演示了一下上面提到的基本的使用，也就是实现基本的网络请求处理。</p>
<pre><code>type engine struct {
}

func (e *engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	switch req.URL.Path {
	case &quot;/&quot;:
		fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, req.URL.Path)
	case &quot;/hello&quot;:
		for k, v := range req.Header {
			fmt.Fprintf(w, &quot;Header[%q] = %q\n&quot;, k, v)
		}
	default:
		fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)
	}
}
func main() {
	en := new(engine)
	log.Fatal(http.ListenAndServe(&quot;:9999&quot;, en))
}
</code></pre>
<p>然后我们就可以开始实现框架的第一步，路由映射关系。</p>
<h2 id="框架映射结构">框架映射结构</h2>
<p>最后实现的源码：</p>
<pre><code>package gee

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

// HandlerFunc defines the request handler used by gee
type HandlerFunc func(http.ResponseWriter, *http.Request)

// Engine implement the interface of ServeHTTP
type Engine struct {
	router map[string]HandlerFunc
}

// New is the constructor of gee.Engine
func New() *Engine {
	return &amp;Engine{router: make(map[string]HandlerFunc)}
}

func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) {
	key := method + &quot;-&quot; + pattern
	engine.router[key] = handler
}

// GET defines the method to add GET request
func (engine *Engine) GET(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;GET&quot;, pattern, handler)
}

// POST defines the method to add POST request
func (engine *Engine) POST(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;POST&quot;, pattern, handler)
}

// Run defines the method to start a http server
func (engine *Engine) Run(addr string) (err error) {
	return http.ListenAndServe(addr, engine)
}

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	key := req.Method + &quot;-&quot; + req.URL.Path
	if handler, ok := engine.router[key]; ok {
		handler(w, req)
	} else {
		fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)
	}
}
</code></pre>
<p>在这里我们可以看到的是我们这里的实现的效果和gin很像，这里我们建立了一个map，用来映射路由和函数，然后这里我们在存储的时候，我们还将请求的方法进行了一个存储，也就是说相同的路径但是不同的请求方式他最后调用的函数也是不一样的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[错误异常机制]]></title>
        <id>https://IseEkko.github.io/post/cuo-wu-yi-chang-ji-zhi/</id>
        <link href="https://IseEkko.github.io/post/cuo-wu-yi-chang-ji-zhi/">
        </link>
        <updated>2022-04-09T03:12:07.000Z</updated>
        <summary type="html"><![CDATA[<p>在编写程序的时候很容易遇见的一个问题，也是必须要处理的，今天简单的去了解了一下什么是错误什么是异常，在go中是如何处理的</p>
]]></summary>
        <content type="html"><![CDATA[<p>在编写程序的时候很容易遇见的一个问题，也是必须要处理的，今天简单的去了解了一下什么是错误什么是异常，在go中是如何处理的</p>
<!-- more -->
<h2 id="错误异常">错误异常</h2>
<p>在了解怎么做之前，我们首先应该要明白，什么是错误，什么是异常</p>
<ul>
<li>错误：可以预测</li>
<li>异常：不可预测<br>
在程序的编码中，我们写的代码有时候我们知道他可能会出现什么错，那么我们就叫做错误，比如说我们写的这个代码：</li>
</ul>
<pre><code>func pan(i int) {
	if i == 0 {
		err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
		panic(err)
	}
}
</code></pre>
<p>如果我们用这个判断除数的话，那么可以知道除数是不能为0的，如果出现了除数为0那么他肯定是错误的，这种可以预测的，我们称之为错误。其他的错误是我们没有预测那么那些错误就是异常。感觉说的有点小绕。<br>
其实简单的就是，预测的叫做错误没有预测的就是异常。</p>
<h2 id="如何进行处理">如何进行处理</h2>
<p>在go中如果我们执行了panic，我们会得到下面这种结构。首先我们来看一下我们执行的代码：</p>
<pre><code>func main() {
  pan(0)
  fmt.Println(&quot;main安全退出&quot;)
}
func pan(i int) {

  if i == 0 {
  	err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
  	panic(err)
  }
}
</code></pre>
<p>这里我们输入了0，那么肯定是会执行panic函数的，那么执行了panic函数过后程序就会直接被终止，所以我们会得到下面这个结果。</p>
<pre><code>/private/var/folders/55/2cf9m54s36q_1yf2j1svkf580000gn/T/GoLand/___go_build_awesomeProject1_2022_4_9_PanicAndRecover
panic: i 不能为 0 %!(EXTRA time.Time=2022-04-09 11:19:17.141969 +0800 CST m=+0.000072167)

goroutine 1 [running]:
main.pan(0x0)
        /Users/lizhongzheng/GolandProjects/awesomeProject1/2022-4-9/PanicAndRecover/main.go:16 +0xd0
main.main()
        /Users/lizhongzheng/GolandProjects/awesomeProject1/2022-4-9/PanicAndRecover/main.go:9 +0x24
</code></pre>
<p>这里会清楚的写到在那里执行执行了panic，然后panic的错误是什么等相关信息。<br>
但是我们这里就会产生一个疑问，如果我们的程序正在运行但是不想让这个Panic将我们的程序直接终止，我们应该怎么处理。我们看到这里的结果是直接终止了程序的执行，最后是没有回到主函数执行输出的。<br>
对着这种处理，在php和java中使用有try catch这个方法进行处理，但是在go中是没有的，那么应该如果进行类似的处理呢？<br>
这里我们就要使用到一个recover()函数了，这个函数和panic一般都是一起出现的，这个函数的作用就是处理panic报的错误，然后收集不让程序直接退出。<br>
这里我们来演示一下有recover这个函数后，程序的执行吧，还是先上我们执行的源码：</p>
<pre><code>func main() {
	pan(0)
	fmt.Println(&quot;main安全退出&quot;)
}
func pan(i int) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(&quot;检测到错误&quot;, err)
		} else {
			panic(&quot;检测失败&quot;)
		}
	}()
	if i == 0 {
		err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
		panic(err)
	}
}
</code></pre>
<p>这个我们使用的defer，延迟处理函数，然后在这里return前进行一个调用，对于defer函数在以后我们再进行讲解，在这里我们知道它是延迟处理就可以了。<br>
然后下面是我们的执行结果：</p>
<pre><code>/private/var/folders/55/2cf9m54s36q_1yf2j1svkf580000gn/T/GoLand/___go_build_awesomeProject1_2022_4_9_PanicAndRecover
检测到错误 i 不能为 0 %!(EXTRA time.Time=2022-04-09 11:27:48.221554 +0800 CST m=+0.000130459)
&lt;!-- more --&gt;

main安全退出
</code></pre>
<p>不错我们执行到了最后，main函数安全退出，我们就演示到这里了，这就是go处理错误和异常的方法了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go_context（1）]]></title>
        <id>https://IseEkko.github.io/post/go_context-xue-xi-1/</id>
        <link href="https://IseEkko.github.io/post/go_context-xue-xi-1/">
        </link>
        <updated>2022-04-08T08:25:53.000Z</updated>
        <summary type="html"><![CDATA[<p>一直对context这个东西保持一个神秘感，今天对这部分内容进行了一个查看，可能理解不是很到位。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一直对context这个东西保持一个神秘感，今天对这部分内容进行了一个查看，可能理解不是很到位。</p>
<!-- more -->
<h2 id="context是什么">context是什么</h2>
<p>首先对于context这个东西到底是什么，在之前我的学长们总是给说什么上下文，但是呢我总是不理解这个东西，上下文？？？一脸的问号，什么是上下文？<br>
在我们交流的语言中呢，比如英语这个玩意（我贼垃圾），比如一个单词在这里是这个意思，但是换个地方他就不是那个意思了，，，emm也不知道大家理解没有，大概就是这个意思。<br>
然后官方一点的回答，什么是context。这个东西是怎么产生的。<br>
其实这个东西是在go1.17的时候加入的官方库的，具体的产生和go的并发是有关系的，在go的编程中最重要的东西就是channel和goroutine这两个玩意。在我们写go程序的时候，我们需要调用函数，在调用的时候很有可能我们会开启一连串的goroutine，那么我们怎么来达到一个特殊数据的一些传递和对goroutine的关闭呢？通过信号量这个玩意，使用sync.Wait来对它进行一个信号量的管理，其实这样肯定是不好的。所以我们的contxet就诞生了。</p>
<pre><code>简单的来说：context的作用就是在不同的goroutine之间进行同步，请求特定的数据取消信号量以及处理请求的截止时间。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1649408733993.png" alt="" loading="lazy"></figure>
<h2 id="context的使用">context的使用</h2>
<p>现在我们来看一下这个玩意我们应该怎么使用</p>
<h3 id="context创建">Context创建</h3>
<p>要想使用那么第一步肯定就是对这个东西的创建。<br>
context包主要提供了两种方式创建context:</p>
<ul>
<li>context.Backgroud()</li>
<li>context.TODO()</li>
<li>这两个函数其实只是互为别名，没有差别，官方给的定义是：<br>
context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来。<br>
context.TODO 应该只在不确定应该使用哪种上下文时使用；<br>
所以在大多数情况下，我们都使用context.Background作为起始的上下文向下传递。<br>
我们可以查看一下这部分的源码：<br>
<img src="https://IseEkko.github.io//post-images/1649407256932.png" alt="" loading="lazy"><br>
我们可以很清楚的看见，这两个最后返回的东西其实是一样的。</li>
</ul>
<h3 id="四个重要的函数">四个重要的函数</h3>
<p>我们创建过后，我们可以看到他可以调用的四个重要函数</p>
<pre><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
</code></pre>
<p>这里我们看到了这个四个重要的函数，这里我们简单的说一下它是干什么用的，后面我再对四个函数进行一个详细的学习和总结</p>
<h3 id="withvalue携带数据">WithValue携带数据</h3>
<h3 id="withtimeout超时控制">WithTimeout超时控制</h3>
<h3 id="withcancel取消控制">withCancel取消控制</h3>
<h3 id="withdeadline就是对withcancel取消控制的调用">WithDeadline就是对withCancel取消控制的调用</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三数之和]]></title>
        <id>https://IseEkko.github.io/post/san-shu-zhi-he/</id>
        <link href="https://IseEkko.github.io/post/san-shu-zhi-he/">
        </link>
        <updated>2022-04-08T05:17:18.000Z</updated>
        <content type="html"><![CDATA[<p>三数之和，这个题目做过了很多次但是还是有点不清楚，今天重新做了一下。</p>
<h2 id="题目解析">题目解析</h2>
<p>这个题目理解起来还是很简单的，也就是在一个数组里面我们将三个数字加起来等于0那么记录一下就可以了，所以最后的输出肯定是一个二维数组。首先我们要做的事情就是找出来这些数字。<br>
这里我们使用迭代的方式，我们首先将数组进行排序，然后使用双指针的方式将数字找出来，首先我们先取出一个数字，然后我们就将一个三个数字的题目转换成一个两个数字的题目。<br>
然后我们在找两个数字的时候，因为我们的数组是进行了排序的，所以我们就将情况分解出来，也就是说如果最后三个数字的和大于零那么就是说明右边界太大了，那么我们就调整右边界，同理我们可以调整左边界。<br>
这里需要注意一个点，也就是我们在最后的结构，我们不要重复的，所以相同的数字我们就要将它排除，这里我们有三段代码做了这件事情。</p>
<h2 id="解题源码">解题源码</h2>
<pre><code>func threeSum(nums []int) [][]int {
  sort.Ints(nums)
  return TreeNum(nums)
}


func TreeNum(nums []int)[][]int{
   res := make([][]int,0)
   for i := 0;i&lt;len(nums)-2;i++{
       n1 := nums[i]
       if n1 &gt; 0{
           break
       }
       if i &gt; 0 &amp;&amp; n1 == nums[i-1]{
           continue
       }

       l,r := i+1,len(nums)-1
       for l &lt; r{
                n2 ,n3 := nums[l],nums[r]
                if n1+n2+n3 == 0 {
                    res = append(res,[]int{n1,n2,n3})
                    for l&lt;r &amp;&amp; nums[l] == n2{
                        l++
                    }
                    for l&lt;r &amp;&amp; nums[r] == n3{
                        r--
                    }
                }else if n1+n2+n3 &lt; 0{
                    l++
                }else{
                    r--
                }
       }
   }
   return res
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语言并发-订阅者模式]]></title>
        <id>https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/">
        </link>
        <updated>2022-04-07T07:44:39.000Z</updated>
        <content type="html"><![CDATA[<p>在之前的学习中，接触到了消息队列的一些知识，然后今天在看书的时候，发现了一个使用go channel完成了一个订阅者模式的并发demo。</p>
<h2 id="订阅者模式">订阅者模式</h2>
<p>关于订阅者模式，在这里给大家讲解一下，订阅者模式其实就是将产生的消息，给多个订阅者，然后订阅者可以看到这里订阅的消息。<br>
这里实现的时候呢，因为有并发的知识，所以我们用到了协程，下面我们来具体的实现一下。</p>
<h2 id="具体的实现流程">具体的实现流程</h2>
<h3 id="创建订阅者结构">创建订阅者结构</h3>
<pre><code>type (
	subscriber chan interface{}         //订阅者的通道
	topicFunc  func(v interface{}) bool //主题过滤器
)

//发布者对象
type Publisher struct {
	m           sync.Mutex               //读写锁
	buffer      int                      //订阅队列缓存大小
	timeout     time.Duration            //发布者超时时间
	subscribers map[subscriber]topicFunc //订阅者消息
}
</code></pre>
<p>上面我们定义了基本的订阅者的结构，上面也有对订阅者字段的解释，这里着重理解的东西就是：</p>
<pre><code>subscribers map[subscriber]topicFunc //订阅者消息
</code></pre>
<p>这个结构其实就是订阅者模式的一个重要的结构，这里存放的是订阅者的过滤器，也就是通过这个结构我们可以清楚的知道，订阅者订阅的是那个主题。</p>
<h3 id="构造函数">构造函数</h3>
<p>使用构造函数构造出订阅者的实体，然后进行后面的操作</p>
<pre><code>func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		buffer:      buffer,
		timeout:     publishTimeout,
		subscribers: make(map[subscriber]topicFunc),
	}
}
</code></pre>
<h3 id="添加订阅者信息">添加订阅者信息</h3>
<pre><code>//订阅全部，也就是不加入过滤器
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

//添加一个订阅者，同时订阅者是有过滤器的
//这里其实就是返回一个订阅者的信息，然后添加上过滤器
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}
</code></pre>
<p>这里就是添加订阅者，这里添加的时候添加订阅者的过滤器，也就是增加一个映射关系。</p>
<h3 id="添加主题">添加主题</h3>
<pre><code>//发布一个主题
func (p *Publisher) Publish(v interface{}) {
	p.m.Lock()
	defer p.m.Unlock()
	var wg sync.WaitGroup
	//这里返回的是订阅者，然后后面是返回的过滤器
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.sendTopic(sub, topic, v, &amp;wg)
	}
	wg.Wait()
}

//发布主题，可以容忍一定的超时
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}
	select {
	case sub &lt;- v:
	case &lt;-time.After(p.timeout):
	}
}
</code></pre>
<p>这里我们使用到的并发式的添加消息，这里使用到了sync.WaitGroup，进行协程的同步。</p>
<h3 id="关闭订阅者模式">关闭订阅者模式</h3>
<pre><code>//关闭发布对象，同时关闭
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()
	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}
</code></pre>
<h2 id="最后的测试">最后的测试</h2>
<pre><code>func main() {
	p := NewPublisher(100*time.Millisecond, 10)
	defer p.Close()
	all := p.Subscribe()
	golang := p.SubscribeTopic(func(v interface{}) bool {
		if s, ok := v.(string); ok {
			return strings.Contains(s, &quot;golang&quot;)
		}
		return false
	})
	p.Publish(&quot;hello,lzz&quot;)
	p.Publish(&quot;hello,golang&quot;)
	go func() {
		for msg := range all {
			fmt.Println(&quot;all:&quot;, msg)
		}
	}()
	go func() {
		for msg := range golang {
			fmt.Println(&quot;golang:&quot;, msg)
		}
	}()
	time.Sleep(3 * time.Second)
}
</code></pre>
<p>最后的输出结果：<br>
<img src="https://IseEkko.github.io//post-images/1649321380937.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>