<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>BytesLzz</title>
    <updated>2022-03-21T15:19:31.600Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>做好每一件事，读好每一本书，天道酬勤</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, BytesLzz</rights>
    <entry>
        <title type="html"><![CDATA[全排列问题]]></title>
        <id>https://IseEkko.github.io/post/quan-pai-lie-wen-ti/</id>
        <link href="https://IseEkko.github.io/post/quan-pai-lie-wen-ti/">
        </link>
        <updated>2022-03-21T15:16:30.000Z</updated>
        <content type="html"><![CDATA[<p>今天遇见的题目是全排列的问题，这里进行一个总结<br>
<img src="https://IseEkko.github.io//post-images/1647875887964.png" alt="" loading="lazy"><br>
题目解析<br>
今天进行全排列的解析，给一个数组，然后进行排列组合，给出最后所有的排列组合。有一定的经验所以我们可以画出下面这个图<br>
<img src="https://IseEkko.github.io//post-images/1647875897982.png" alt="" loading="lazy"><br>
这里我们可以很清楚的看到，这里使用的方式是回溯，那么我们就可以开始写这个代码了。<br>
这个题目在做的时候，我们使用到的是slice的一些方法，删除第k个元素，然后加入第k个元素。<br>
达到回溯的效果。<br>
解题源码<br>
<img src="https://IseEkko.github.io//post-images/1647875924078.png" alt="" loading="lazy">		<br>
稍微加一点难度就是这个数组是无序的有重复的数组。<br>
这个时候在循环的时候就要判断数组中重复的数字。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路由器和交换机的区别]]></title>
        <id>https://IseEkko.github.io/post/lu-you-qi-he-jiao-huan-ji-de-qu-bie/</id>
        <link href="https://IseEkko.github.io/post/lu-you-qi-he-jiao-huan-ji-de-qu-bie/">
        </link>
        <updated>2022-03-21T15:15:55.000Z</updated>
        <content type="html"><![CDATA[<p>路由器和交换机，他们位于不同的位置，<br>
交换机处于网络中的数据链路层，根据mac地址进行转发，一般用于构建简单的内部网络<br>
路由器，路由器是在网络层中进行工作的，根据的是ip地址进行转发的。一般用于构建复杂的网络。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路由转发]]></title>
        <id>https://IseEkko.github.io/post/lu-you-zhuan-fa/</id>
        <link href="https://IseEkko.github.io/post/lu-you-zhuan-fa/">
        </link>
        <updated>2022-03-21T15:11:49.000Z</updated>
        <summary type="html"><![CDATA[<p>在网络传输的过程中，会经过很多的路由，那么我们如何进行转发的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在网络传输的过程中，会经过很多的路由，那么我们如何进行转发的呢？</p>
<!-- more -->
<h2 id="流程">流程</h2>
<p>在传输的过程中，路由需要做的，就是把数据包传输到他该去的地方，在如今的网络中，已经有很多且复杂的网络。这个时候我们需要做的是什么呢。<br>
首先从ip数据包中提取出目的主机的io地址，然后找到他所在的网络。<br>
这个时候判断ip所在的网络是不是和本路由直接相连，如果是那么就直接进行转发。<br>
如果不是，路由会检查路由表，看路由表中是不是有ip地址的特定主机路由，如果有那么就直接跳转到下一跳路由中去。<br>
如果我们没有找到对应的特定主机，路由器会检查路由表，使每一行的子网掩码与目的的ip匹配，如果找到了，则按照路由表转发下一跳路由中<br>
如果没有找到，就按照默认的路由转发到默认路由中，不然无法找到路由那么就向源主机报错。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三月二十号-周总结]]></title>
        <id>https://IseEkko.github.io/post/san-yue-er-shi-hao-zhou-zong-jie/</id>
        <link href="https://IseEkko.github.io/post/san-yue-er-shi-hao-zhou-zong-jie/">
        </link>
        <updated>2022-03-20T05:27:33.000Z</updated>
        <content type="html"><![CDATA[<p>一周过去了，在周末把这个星期的收获总结一遍。</p>
<h2 id="计算机网络">计算机网络</h2>
<p>本周对计算机网络进行了一定的学习，主要学习的范围是应用层和传输层。</p>
<h3 id="应用层">应用层</h3>
<h4 id="keep-alive和非keep-alive">keep-alive和非keep-alive</h4>
<p>在应用层中，我们主要要学习的东西是http协议相关的知识，本周对http协议也有了新的一个认识，首先我们来看一下http协议。<br>
http协议是我们在做web应用的一个协议，他是一个请求/响应式的一种协议，也就是发起请求然后等待一个响应。说到请求和响应我们就想到了我们首先要建立连接，在http中建立的是tcp协议，在http的演进中这个连接的方式发生了改变，在http1.1前使用的是非长连接方式，在这个连接方式中也就是为每一个请求建立一个tcp连接。然后我们知道的是TCP建立一个连接会消耗很多的资源，所以从速度上来说就慢了许多，后面我们会细说TCP连接的三个握手和四次挥手。这里下面我们放一张图也就是长连接和非长连接的示意图：<br>
<img src="https://IseEkko.github.io//post-images/1647762950584.png" alt="" loading="lazy"><br>
但是这个两个方式都是优缺点的，第一个非长连接的缺点很明显当很多人进行访问的时候这个时候对于服务器的压力是很多的，然后第二个长连接就是保持连接的时间如果时间不合理也会让服务器的资源被无效的占用。这个问题我们解决的办法就是正确的设置keepalive-timeout的时间。</p>
<h4 id="如何知道http协议传输的报文长度">如何知道http协议传输的报文长度</h4>
<p>对于小文件来说，服务器会直接在响应报文的content-Lenth字段上写上<br>
对于大文件来说，在http1.1以后用的方式是分块传输，这个时候客户端只会知道进行的是分块传输，是通过Transfer-Encoding：chunked字段，这里我们要知道不会传输数据的长度，每一个包会包含一个十六进制的长度值和数据，最后一个分块长度是0，表示实体的结束，客户端可以根据这个确认数据接收完成。</p>
<h4 id="大文件的传输方式">大文件的传输方式</h4>
<p>对于大文件我们有几种传输方式分别是：数据压缩、分块传输、范围请求、多段数据请求<br>
对于这四种方式适用的地方是不一样的，首先我们先来说一下数据压缩，<br>
对于数据压缩来说，很简单就是选择一个压缩算法，然后对数据进行压缩然后进行传输，我们都知道压缩完的数据是变小了的，这里我们有一个问题，我们如何选择算法，根据什么呢？<br>
压缩算法的选择看得是Transfer-Encoding：chunked字段，在这个字段里面我们可以知道浏览器支持的压缩算法，然后服务端会对比自己支持的算法然后进行选择。但是这个传输方式的缺点是很明显的，对于文本文件是没有问题的，但是呢我们要知道对于图片和视频文件来说，我们知道要知道的是这些文件都是经过高度压缩了的，所以压缩算法对于他来说是无效的。<br>
分块传输，我们将大文件拆分成小文件进行传输，这样的话我们的网络中就不会占用过多的时间可以节省服务的资源。详细的内容请查看以前的博客。<br>
范围请求，我们在观看视频的时候，很多时候需要进行快进，那么我们如何办到呢。我们使用到的技术就是范围请求。在http中有一个range字段，因为在http中这个功能可有可无的，所以我们要通过Accept-Ranges:bytes明确告知客户端：我是支持范围请求的。<br>
多段数据进行传输，这种情况需要使用一种特殊的MIME类型:multipart/byteranges，表示报文的div是由多段字节序列组成的，并且还要用一个参数boundary=xxx给出段之间的分隔标记。</p>
<h4 id="http协议不同版本之间的区别">http协议不同版本之间的区别</h4>
<p>1.0和1.1的区别<br>
• 缓存处理：<br>
1.1较1.0相比缓存的策略更加的灵活<br>
• 节约带宽：<br>
在1.1中添加了range字段，可以请求资源的部分内容，这使得开发者可以线程的请求某一资源。从而重新的利用带宽资源进行高效的并发<br>
• 错误请求的管理：<br>
1.1较1.0新增了24个状态码<br>
• Host 请求头：<br>
早期的服务器，都是一个机器处理单一的任务，所以可以直接用ip进行标识，但是后面有了虚拟机过后，一个主机可以有多个虚拟机，然后这个时候我们为了支持这个虚拟主机，1.1就增加了host请求头<br>
• 长连接：<br>
HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。<br>
1.x和2.0 的区别<br>
• 二进制传送：<br>
之前版本 数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有场景； 2.0传送的是二进制，相当于统一了格式<br>
• 多路复用：<br>
1.1虽然默认复用TCP连接，但是每个请求是串行执行的，如果前面的请求超时，后面的请求只能等着（也就是线头阻塞）； 2.0的时候每个请求有自己的ID，多个请求可以在同一个TCP连接上并行执行，不会互相影响<br>
• header压缩：<br>
每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编号就行，用的时候只需要拿着编号去表里查找就行，<br>
减少了传输的数据量<br>
• 服务端推送：<br>
服务器会在客户端没发起请求的时候主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html页面相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接从缓存中获取，就不需要再发起请求了</p>
<h4 id="dns的作用和原理">DNS的作用和原理</h4>
<p>在网络的世界里面，我们看着文字的符号便于记忆，但是对于计算机来说有规律的数字更好的理解，然后就有了DNS。理解就是一个分布式的数据库，然后要找主机我们就更具域名进行查询。</p>
<h3 id="传输层">传输层</h3>
<p>学习完了应用层的基本内容后我们进入了传输层的学习，传输层也就是对数据进行传输的地方，这里主要讲解的就是TCP传输协议的知识，我们知道它是可靠的数据传输方式，这个要归功于rdt机制，对传输的数据进行确认后再发送后面的数据加上重传机制，保证了TCP的可靠传输。</p>
<h4 id="tcp连接是如何进行连接的">TCP连接是如何进行连接的</h4>
<p>TCP的连接的过程，也就是我们以前常说的三次握手，那么这个三次握手的过程是怎么样的呢。<br>
<img src="https://IseEkko.github.io//post-images/1647762973573.png" alt="" loading="lazy"><br>
上图中很好的展示了TCP三次握手的过程，在这里面我们需要注意的点是，在三次握手中，第一次和第二次握手是不携带数据传输的，但是要占用序号位，第三次握手时候可以包含数据，但是这里不一样的是，携带了数据就要占用序号位，如果没有数据传输那么就不会进行序号位的占用。<br>
####为什么是三次握手不是两次呢<br>
在TCP中第一次握手时候是客户端发起的请求，然后为了确保数据的可靠，那么我们就要进行数据的确认，第二次握手的时候我们对第一次握手的数据进行了确认，但是第二次握手的数据没有得到确认那么这个方式就是不可靠的，比如说我们进行第二次握手的时候，其实根本没有收到ack数据包进行第一次握手的确认，那么当客户端进行再次确认的时候，又会进行第一次握手的操作，然后服务端再一次进行ack确认报文的发送，那么对于客户端来说就只有一个连接，但是对于服务端来说就两个连接，这样的数据传输就没有可靠性的。所以我们要进行三次握手而不是两次。</p>
<h4 id="保证数据的可靠性">保证数据的可靠性</h4>
<p>TCP是全双工的信道，如何避免乱序和丢包问题呢？在TCP协议中，我们之前说了一下他是传输一个数据等待确认后再进行后面的传输。<br>
这里我们详细的讲解一下，在TCP传输的过程中会建立一个发送端缓存区，然后截取数据的一部分，然后加上序列号、长度、数据内容然后进行传输，传输后会等待一个确认的报文，ack就是传输确认的报文，也就是ack报文，这个报文包含什么那些东西呢？ACK = 序列号 + 长度 = 下一个起始序列号。这样就保证了数据的可靠性。<br>
<img src="https://IseEkko.github.io//post-images/1647762983716.png" alt="" loading="lazy"></p>
<h4 id="tcp拥塞控制采取的四种算法">TCP拥塞控制采取的四种算法</h4>
<p>TCP传输不仅数据传输可靠，而且在传输在时候会更具网络的状况进行流量的管控。这里我们就简单的说一下这四种算法</p>
<h5 id="慢开始">慢开始</h5>
<p>在网络中我们不知道网络中的通信状态，这个时候TCP会发送一个很小的数据包进行通道的侦测，然后慢慢的增加窗口的大小。</p>
<h5 id="拥塞避免">拥塞避免</h5>
<p>这里我们为了拥塞窗口的缓慢增大，每经过一个RTT，我发送窗口就会加一。<br>
当网络的拥塞发生的时候，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p>
<h5 id="快恢复">快恢复</h5>
<p>快恢复算法，和快重传算法是配合使用的，连续接收到三次确认后，会减半阀值，,窗口长度起点和阙值一样，执行拥塞避免，线性递增</p>
<h5 id="快重传">快重传</h5>
<p>当接收方接收到一个失序的数据包的时候马上进行重传。我们假设有四个数据包，分别是1，2，3，4，然后我们这里接收到的是1，3，4。这个时候发送端一直接收到的是数据包一的确认包，然后这个接收到三次1的确认后，我们就会立即重新传输对方没有接收到的报文。由于发送发尽快发送没有接收到的报文段，所以快速重传会提高网络的吞吐量。</p>
<h4 id="tcp断开连接的过程">TCP断开连接的过程</h4>
<p>上面我们对TCP连接的建立和传输中遇见的问题解决办法，进行了一次总结，然后下面我们说一下TCP连接的断开，也就是四次挥手的过程，在四次挥手的过程中也有我们需要注意的地方。首先我们先看一下整个过程的流程图。<br>
<img src="https://IseEkko.github.io//post-images/1647762278280.png" alt="" loading="lazy"><br>
在这里我们需要知道的是在最后的时候发起断开连接的端，会进行一个等待后才会关闭。我们要等待这个时间呢？<br>
等待这个时间其实是为了等待最后确认的ack到达没有到达接收端，因为如果没有接收到，接受端会再次发送fin包进行最后的确认。</p>
<h2 id="redis">Redis</h2>
<p>本周只学习了redis的一个很小的部分，就是string类型。<br>
一些基本的操作详细请看之前发的博客。</p>
<h2 id="go工程问题">Go工程问题</h2>
<p>在这周海子给我说了一下在面试经常面的问题，这里有一个问题就是对协程的使用，就是对协程的使用，使用两个协程进行交替打印奇偶数字。<br>
<img src="https://IseEkko.github.io//post-images/1647762593057.png" alt="" loading="lazy"><br>
<img src="https://IseEkko.github.io//post-images/1647762605452.png" alt="" loading="lazy"><br>
上面是两种解法，在看这里的时候直接看代码就像理解就可以了。</p>
<h3 id="go秒杀">Go秒杀</h3>
<p>本周开始秒杀系统的书写在本次开发中会把问题记录得很细致，每一个知识点都会有记录，这里对本周的学习进行一个总结。</p>
<h4 id="rabbitmq">RabbitMQ</h4>
<p>本周对系统的准备主要学习的RabbitMQ消息队列的使用和几个模式的书写。<br>
每种模式的书写可以查看之前的博客更加的细致。也更好的理解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP拥塞控制采取的四种算法]]></title>
        <id>https://IseEkko.github.io/post/tcp-yong-sai-kong-zhi-cai-qu-de-si-chong-suan-fa/</id>
        <link href="https://IseEkko.github.io/post/tcp-yong-sai-kong-zhi-cai-qu-de-si-chong-suan-fa/">
        </link>
        <updated>2022-03-19T05:52:42.000Z</updated>
        <content type="html"><![CDATA[<p>在TCP拥塞控制中，那么他在是怎么进行的的呢，一共是四个算法。</p>
<h2 id="慢开始">慢开始</h2>
<p>在一开始的时候，TCP不知道网络现在的状态就会先发送一个小的数据包进行传输，用来侦测网络的状态，然后慢慢的增加窗口的长度。<br>
在这里我们就有一个问题，也就是说，我们的窗口肯定不是无限在增长的，然后在增长的过程中，我们肯定是要做限制的，这个限制就是：ssthresh。</p>
<h2 id="拥塞避免">拥塞避免</h2>
<p>这里我们为了让拥塞窗口缓慢的增大，每经过一个RTT，发送方的拥塞窗口就会进行加一，然后这个时候窗口就会进行线性的增长。<br>
在网络拥塞发生的时候，让新的慢开始门限变为发生拥塞时候的一半，，并将拥塞窗口置为1，然后再次重复两种算法（慢开始和拥塞避免），这个时候一瞬间会将网络中的数据量大量的降低。</p>
<h2 id="快重传">快重传</h2>
<p>当接受方收到一个失序的数据包的时候，马上进行重传，我们假设没有四个数据包，分别是1，2，3，4，然后我们接收到了1，3，4。这个时候接受端会发送确认包，当发送端接收到三次一的确认的时候我们，就会立即传输没有接收到的数据包。</p>
<h2 id="快恢复">快恢复</h2>
<p>快恢复算法和快重传算法是配合使用的，连续接收到三次确认后会减半阀值，窗口长度和阀值一样，执行拥塞避免，线性递增。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Topic话题模式]]></title>
        <id>https://IseEkko.github.io/post/topic-hua-ti-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/topic-hua-ti-mo-shi/">
        </link>
        <updated>2022-03-18T01:24:09.000Z</updated>
        <summary type="html"><![CDATA[<p>我觉得是路由模式的升级版。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我觉得是路由模式的升级版。</p>
<!-- more -->
<h2 id="解析">解析</h2>
<p>对于这个模式，我觉得就是对路由模式的升级，在路由模式中，我们可以根据配置的路由进行消费者的发送，然后这里是通过配置符号进行消费者的发送，这里有可能我们用到的是给多个消费者进行发送。</p>
<h2 id="示意图">示意图</h2>
<p><img src="https://IseEkko.github.io//post-images/1647617723443.png" alt="" loading="lazy"><br>
这个模式的实例创建是和路由模式是相同的，进行路由名称和交换机模式的传输，通过这两个进行实例的创建。<br>
消息的处理<br>
这里无论是生产和消费消息，和路由模式的区别就是在交换机创建时候的kind的选择<br>
<img src="https://IseEkko.github.io//post-images/1647617735245.png" alt="" loading="lazy"><br>
然后在使用的时候，#代表的就是所有，然后*代表的是占位的意思。<br>
这个主要是仔细看一下案例就可以。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Routing路由模式]]></title>
        <id>https://IseEkko.github.io/post/routing-lu-you-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/routing-lu-you-mo-shi/">
        </link>
        <updated>2022-03-18T01:23:15.000Z</updated>
        <summary type="html"><![CDATA[<p>路由模式，和订阅者模式的区别在于，他可以进行消息指定给哪个消费者。</p>
]]></summary>
        <content type="html"><![CDATA[<p>路由模式，和订阅者模式的区别在于，他可以进行消息指定给哪个消费者。</p>
<!-- more -->
<h2 id="路由模式示意图">路由模式示意图</h2>
<p><img src="https://IseEkko.github.io//post-images/1647617775064.png" alt="" loading="lazy"><br>
这里我们是如何做到，消息处理的指定呢？<br>
在创建路由模式的实例的时候，我们需要传入的参数有两个，一个是交换机名称，一个是路由的key。在这里总结的时候我们猜测一波是这个key起到的指定作用。<br>
消息的生产<br>
<img src="https://IseEkko.github.io//post-images/1647617793163.png" alt="" loading="lazy"><br>
上面是路由模式发送消息的完整代码，从中我们可以看到，首先我们进行了一个交换机的创建，然后在发送消息的时候我们的key用的是routkey。<br>
消息的消费<br>
<img src="https://IseEkko.github.io//post-images/1647617804028.png" alt="" loading="lazy"><br>
除了队列和交换机的创建，这里我们进行绑定的时候传入了三个参数，队列的名称，routkey，和交换机。<br>
后面和之前的相同。<br>
如何完成指定发送呢？<br>
在这里，我们的发送端和接受端，都注册了同一个交换机，然后交换机在进行数据发送的时候是通过routkey的值把数据进行指定传输的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[publish订阅者模式]]></title>
        <id>https://IseEkko.github.io/post/publish-ding-yue-zhe-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/publish-ding-yue-zhe-mo-shi/">
        </link>
        <updated>2022-03-17T15:08:24.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://IseEkko.github.io//post-images/1647529790148.png" alt="" loading="lazy"><br>
订阅者模式中，我们加入了一个交换机，然后这个交换机会把消息转发给所有的消费者，所有的消费者拿到的消息都是一样的。</p>
<h2 id="消息发送">消息发送</h2>
<p>在这个模式中，我们首先要创建一个exchange，和simple模式不同的地方，在simple模式中我们创建的是队列<br>
<img src="https://IseEkko.github.io//post-images/1647529796092.png" alt="" loading="lazy"><br>
然后是对消息的发送也有不同的地方，在simple模式中，我们的key是队列名称。<br>
<img src="https://IseEkko.github.io//post-images/1647529802002.png" alt="" loading="lazy"></p>
<h2 id="消息处理">消息处理</h2>
<p>在消息处理的时候，我们首先还是要先创建交换机，然后再进行后面的处理。<br>
然后我们创建一个队列<br>
<img src="https://IseEkko.github.io//post-images/1647529807910.png" alt="" loading="lazy"><br>
这里我们可以创建出一个队列q，然后这个队列是没有名称的，然后在下面的信息处理中，进行处理。这里我们可以看到绑定到了交换机中，然后进行消息的消费。<br>
<img src="https://IseEkko.github.io//post-images/1647529813618.png" alt="" loading="lazy"><br>
对于这个模式来说，我们消费者和生产者都是通过exchange交换机进行绑定传输消息的。<br>
上面就是对订阅者模式的讲解</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP四次挥手]]></title>
        <id>https://IseEkko.github.io/post/tcp-si-ci-hui-shou/</id>
        <link href="https://IseEkko.github.io/post/tcp-si-ci-hui-shou/">
        </link>
        <updated>2022-03-17T14:20:53.000Z</updated>
        <content type="html"><![CDATA[<p>现在我们需要关闭TCP连接，这个时候我们就需要进行四次挥手操作</p>
<p>四次挥手的步骤<br>
<img src="https://IseEkko.github.io//post-images/1647527228182.png" alt="" loading="lazy"><br>
四次挥手的示意图，这里我们需要知道的事情，在第二次手完成的时候，服务端可以把自己没有发送完的数据进行传输，然后发送fin包进入最终断开确认，然后当客户端返回ack后服务端直接关闭。<br>
为什么客户端会等待<br>
因为在客户端发送完ack后，ack数据包可以会丢失，然后这个时候服务端会一种等待最后确认状态，然后没有等到ack确认包，这个时候会进行fin包的重传，然后刷新超时时间，然后等待ack数据包，所以这里需要有一个客户端的超时等待。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP三次握手]]></title>
        <id>https://IseEkko.github.io/post/tcp-san-ci-wo-shou/</id>
        <link href="https://IseEkko.github.io/post/tcp-san-ci-wo-shou/">
        </link>
        <updated>2022-03-17T14:16:20.000Z</updated>
        <summary type="html"><![CDATA[<p>TCP的三次握手建立好了连接开始数据的传输，那么我们要知道是怎么建立连接的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>TCP的三次握手建立好了连接开始数据的传输，那么我们要知道是怎么建立连接的。</p>
<!-- more -->
<h2 id="建立连接的过程">建立连接的过程</h2>
<p>最开始的时候，客户端和服务器都是处于CLOSED状态，然后主动连接的是客户端，被动打开的是服务器。</p>
<ol>
<li>TCP服务器进程先创建TCB传输控制块，时刻准备接受连接客户端的请求，这个时候服务器进入监听状态。</li>
<li>TCP客户进程也是需要先创建TCB传输控制块，然后想服务器发出连接请求报文，报文的里面的同部位SYN=1，同时选择初始序列号seq=x，此时，TCP客户端进入SYN-SENT（同步发送状态）。<br>
TCP规定SYN不能携带数据，但是需要消耗掉一个序号</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。<br>
确认报文中应该ACK=1，SYN=1，确认号是ack = x+1，同时会给自己初始化一个序列号seq=y，此时TCP服务器进程进入SYN-RCVD（同步收到）状态，这个报文不能携带数据，同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认的报文ACK=1，ack=y+1，自己的序列号seq = x+1，此时，TCP连接建立，然后客户端进入ESTABLISHEN（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则部消耗序号。<br>
<img src="https://IseEkko.github.io//post-images/1647526744143.png" alt="" loading="lazy"></li>
</ol>
<h2 id="简单的流程">简单的流程</h2>
<p>在TCP中，我们三次握手的首先就是客户端发送一个SYN包，然后服务端接收到这个SYN包后，进行初始化建立缓存区，然后发送一个SYN+ACK包进行确认，最后客户端接收到后，发送ACK包进行最后的确认。<br>
在这里需要注意的事情，在第一次和第二次握手的时候我们是不能进行数据的传输的，也就是不能带其他的数据进行传输，然后第三次可以，前两次没有带数据包，然后都要占用一个序号位，第三握手的时候如果带了数据包就会占用序号位，但是如果没有那么久不会占用序号位。</p>
<h2 id="为什么是三次握手">为什么是三次握手</h2>
<p>简单的说就是解决传输不可靠的手段，比如说客户端发出请求，得到了SYN+ACK包后就建立的连接，但是因为某种原因，客户端没有建立起第一个连接，然后重发了SYN包，这个时候服务器又发送了一个SYN+ACK包，这个时候就出现了问题，对于客户端来说这个时候建立了一个连接，但是对于服务器来说就建立了两个，这个时候就产生了错误，导致了数据传输的不可靠并且占用了过多的资源。综上所诉需要三次握手来避免这个问题的产生。</p>
<h2 id="tcp传输过程中保证数据传输的可靠性">TCP传输过程中保证数据传输的可靠性</h2>
<p>因为TCP是全双工的信道，所以下面的结论对于客户端和服务端都是可行的。<br>
在TCP传输中，我们需要处理丢包和乱序问题。<br>
在TCP的传输中，会创建一个发送缓冲区，然后把数据截取一部分，然后加上序列号、长度、数据内容，然后进行传输，当接收方接收到数据后，会回复一个报文，这个报文里面包含ACK确认信息，ACK = 序列号+长度 = 下一个起始序列号。这要一来一会的问答方式保证了数据传输的可靠性。<br>
当丢失了报文，接收端可以要求发送端进行重新发送。<br>
<img src="https://IseEkko.github.io//post-images/1647526753768.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>