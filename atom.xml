<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://IseEkko.github.io/</id>
    <title>isekko</title>
    <updated>2022-03-17T01:37:08.221Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://IseEkko.github.io/"/>
    <link rel="self" href="http://IseEkko.github.io/atom.xml"/>
    <subtitle>对个人笔记的总结，这个网站的笔记将会是我经过提炼过后的笔记。</subtitle>
    <logo>http://IseEkko.github.io/images/avatar.png</logo>
    <icon>http://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, isekko</rights>
    <entry>
        <title type="html"><![CDATA[Simple模式]]></title>
        <id>http://IseEkko.github.io/post/simple-mo-shi/</id>
        <link href="http://IseEkko.github.io/post/simple-mo-shi/">
        </link>
        <updated>2022-03-16T14:53:11.000Z</updated>
        <content type="html"><![CDATA[<p>最简单常用的模式<br>
<img src="http://IseEkko.github.io//post-images/1647442422855.png" alt="" loading="lazy"><br>
创建的过程<br>
首先我们要有一个rabbitmq的结构体，用于创建rabbitmq实例。<br>
<img src="http://IseEkko.github.io//post-images/1647442430003.png" alt="" loading="lazy"><br>
然后我们需要一个全局的连接url：<br>
<img src="http://IseEkko.github.io//post-images/1647442437427.png" alt="" loading="lazy"><br>
在里面我们解释了每一个参数意思。然后我们开始创建这个rabbitmq的实例：这里我们看到上面的结构体，我们可以看到，我们需要传入的参数是三个，<br>
<img src="http://IseEkko.github.io//post-images/1647442444041.png" alt="" loading="lazy"><br>
创建了实例过后我们还要进行连接和获取通道，这样我们就算连接成功了这个rabbitmq。<br>
这里段代码里面我们看到了还有处理错误的代码，这是我们在工程中应该注意的问题。<br>
<img src="http://IseEkko.github.io//post-images/1647442459705.png" alt="" loading="lazy"><br>
然后为了方便这里我们写了一个构造函数：<br>
<img src="http://IseEkko.github.io//post-images/1647442476877.png" alt="" loading="lazy"><br>
生产者逻辑代码<br>
对于生产者代码中，我们首先需要申请队列，因为我们的消息是发送到队列中的。这里需要注意里面的参数意思。<br>
<img src="http://IseEkko.github.io//post-images/1647442484650.png" alt="" loading="lazy"><br>
然后我们请求到了队列，然后我们就要讲这些消息放进队列里面去<br>
<img src="http://IseEkko.github.io//post-images/1647442491154.png" alt="" loading="lazy"><br>
消费者逻辑代码<br>
首先还是一样的，我们首先需要申请队列，这里申请的步骤和上面一样，这里就不再展示，然后这里我们直接展示消费者的核心代码。<br>
我们首先接收到消息<br>
<img src="http://IseEkko.github.io//post-images/1647442497793.png" alt="" loading="lazy"><br>
然后对消息进行处理<br>
<img src="http://IseEkko.github.io//post-images/1647442505223.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DNS的作用和原理]]></title>
        <id>http://IseEkko.github.io/post/dns-de-zuo-yong-he-yuan-li/</id>
        <link href="http://IseEkko.github.io/post/dns-de-zuo-yong-he-yuan-li/">
        </link>
        <updated>2022-03-16T14:48:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dns">DNS</h2>
<p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。</p>
<h2 id="作用">作用</h2>
<p>在人类的世界里面我们最容易知道的也是最好记的就是名称，那么我们给每个主机一个名字我们就知道了是哪个，但是对于计算机来说，最容易记的是编号，有着层级结构的ip地址。为了满足两者的需求我们就有了DNS，也就是说我们可以更具主机名称查询到对应的ip，DNS就是一个分布式的数据库。</p>
<h2 id="dns域名解析的原理">DNS域名解析的原理</h2>
<p>DNS采用的是分布式的设计方案，它的域名空间使用的是树形的层次结构。<br>
<img src="http://IseEkko.github.io//post-images/1647442173978.png" alt="" loading="lazy"><br>
上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。<br>
除了上面的这些服务器外，还有一个不在这个结构里面但是很重要的本地服务器，一般来说，每一个ips都会有至少一个本地服务器，这个服务器的作用就是起到代理的作用，将dns请求发送到上面的三层机构中去寻找对应主机。</p>
<h2 id="dns查询过程">DNS查询过程</h2>
<p>假设主机 A（IP 地址为 abc.xyz.edu） 想知道主机 B 的 IP 地址 （def.mn.edu），如下图所示，主机 A 首先向它的本地 DNS 服务器发送一个 DNS 查询报文。该查询报文含有被转换的主机名 def.mn.edu。本地 DNS 服务器将该报文转发到根 DNS 服务器，根 DNS 服务器注意到查询的 IP 地址前缀为 edu 后向本地 DNS 服务器返回负责 edu 的顶级域名服务器的 IP 地址列表。该本地 DNS 服务器则再次向这些 顶级域名服务器发送查询报文。该顶级域名服务器注意到 mn.edu 的前缀，并用权威域名服务器的 IP 地址进行响应。通常情况下，顶级域名服务器并不总是知道每台主机的权威 DNS 服务器的 IP 地址，<br>
而只知道中间的某个服务器，该中间 DNS 服务器依次能找到用于相应主机的 IP 地址，我们假设中间经历了权威服务器 ① 和 ②，最后找到了负责 def.mn.edu 的权威 DNS 服务器 ③，之后，本地 DNS 服务器直接向该服务器发送查询报文从而获得主机 B 的IP 地址。<br>
<img src="http://IseEkko.github.io//post-images/1647442239749.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http不同版本的区别]]></title>
        <id>http://IseEkko.github.io/post/http-bu-tong-ban-ben-de-qu-bie/</id>
        <link href="http://IseEkko.github.io/post/http-bu-tong-ban-ben-de-qu-bie/">
        </link>
        <updated>2022-03-16T14:45:33.000Z</updated>
        <summary type="html"><![CDATA[<p>讲解与对于不同版本之间的区别</p>
]]></summary>
        <content type="html"><![CDATA[<p>讲解与对于不同版本之间的区别</p>
<!-- more -->
<h2 id="http10和http11的区别">Http1.0和http1.1的区别</h2>
<p>• 缓存处理：1.1较1.0相比缓存的策略更加的灵活<br>
• 节约带宽：在1.1中添加了range字段，可以请求资源的部分内容，这使得开发者可以线程的请求某一资源。从而重新的利用带宽资源进行高效的并发<br>
• 错误请求的管理：1.1较1.0新增了24个状态码<br>
• Host 请求头：早期的服务器，都是一个机器处理单一的任务，所以可以直接用ip进行标识，但是后面有了虚拟机过后，一个主机可以有多个虚拟机，然后这个时候我们为了支持这个虚拟主机，1.1就增加了host请求头<br>
• 长连接：<br>
HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p>
<h2 id="http-1x和http-20的区别">Http 1.X和http 2.0的区别</h2>
<p>• 二进制传送：<br>
之前版本 数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有场景； 2.0传送的是二进制，相当于统一了格式<br>
• 多路复用：<br>
1.1虽然默认复用TCP连接，但是每个请求是串行执行的，如果前面的请求超时，后面的请求只能等着（也就是线头阻塞）； 2.0的时候每个请求有自己的ID，多个请求可以在同一个TCP连接上并行执行，不会互相影响<br>
• header压缩：<br>
每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编号就行，用的时候只需要拿着编号去表里查找就行，减少了传输的数据量<br>
• 服务端推送：<br>
服务器会在客户端没发起请求的时候主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html页面相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接从缓存中获取，就不需要再发起请求了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何知道http的报文长度]]></title>
        <id>http://IseEkko.github.io/post/ru-he-zhi-dao-http-de-bao-wen-chang-du/</id>
        <link href="http://IseEkko.github.io/post/ru-he-zhi-dao-http-de-bao-wen-chang-du/">
        </link>
        <updated>2022-03-16T14:41:05.000Z</updated>
        <summary type="html"><![CDATA[<p>http的报文长度，分为两种情况</p>
]]></summary>
        <content type="html"><![CDATA[<p>http的报文长度，分为两种情况</p>
<!-- more -->
<h2 id="对于小文件">对于小文件</h2>
<p>其实对于小文件来说，服务器会直接在响应报文的Content-Lenth字段写上</p>
<h2 id="对于大文件">对于大文件</h2>
<p>对于大文件来说，http1.1过后才用的方式是，分块传输，这个时候客户端只知道要进行分块传输，是通过Transfer-Encoding：chunked字段，不会传输数据的长度，每一块包会包含十六进制的长度值和数据，最后一个分块的长度值为0，表示的是实体的结束，客户端可以根据这个确认数据接受完成。</p>
<h2 id="补充知识">补充知识</h2>
<p>这里我们讲解一下http是如何进行大文件传输的</p>
<h3 id="1-数据压缩">1. 数据压缩</h3>
<pre><code> 数据压缩手段，通常是浏览器在发送请求的时候会带着Laccept-encoding头字段，这个字段里写的是浏览器支持的压缩格式，这样服务器就可以选择一种方式进行压缩，放在Content-Encoding响应头中，然后把压缩后的原数据发送给浏览器。
 这个方法的缺点也很明显，因为图片和视频已经是高度压缩后的了，所有这里的压缩对于这些文件是无效的。但是这个方法对于文本的数据效果还是很好的所以还是在使用这个方法。
</code></pre>
<h3 id="2-分块传输">2. 分块传输</h3>
<pre><code> 除了压缩外我们还有的方法就是分块传输，也就是我们将一个大文件进行拆分，然 后把一个一个的小文件进行传输，这样我们的网络就不会被大文件占用过多的时间可以节省服务的资源。
 这种化整为零的思路在HTTP协议里就是chunked分块传输编码，在响应报文里用头字段Transfer-Encoding:chunked来表示，意思是报文里的div部分不是一次性发过来的，而是分成了许多的块(chunk)逐个发送。
 分块传输也可以用于流式数据，例如有数据库动态生成的表单页面，这种情况下div数据的长度是未知的，无法在头字段Content-Length给出确切的长度，所以也只能用chunked方式分块发送。
 Transfer-Encoding:chunked和Content-Length这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文里的传输要么是长度已知，要么是长度未知。
    下面是分块传输的编码规则:
    1.每个分块包含两个部分，长度头和数据块
    2.长度头是以CRLF结尾的一行明文，用16进制数字表示长度
    3.数据块紧跟在长度头后，最后也用CRLF结尾，但数据不包含CRLF
    4.最后用一个长度为0的块表示结束
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://IseEkko.github.io//post-images/1647441798333.png" alt="" loading="lazy"></figure>
<h2 id="范围请求">范围请求</h2>
<pre><code> 我们进行了分块过后，我们会发现一个新的问题，也是常见的一个问题，我们比如在看电视的时候，我们想快进，然后我们选择快进的位置，其实我们就是请求了这个资源的某个范围，这样我们如何进行传输呢。
 这里需要知道一个告知用户，我们支持范围请求的一个字段，范围请求不是web服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段Accept-Ranges:bytes明确告知客户端：我是支持范围请求的。
 请求头Range是HTTP范围请求的专用字段，格式是&quot;bytes=x-y&quot;，其中的x和y是以字节为单位的数据范围。
</code></pre>
<p>服务器收到Range字段后，需要做四件事<br>
第一，它必须检查范围是否合法，比如文件只有100个字节，但是请求&quot;200-300&quot;，这就是范围越界了，服务器就会返回状态码416，意思是你的范围请求有误，我无法处理，请在检查一下<br>
第二，如果范围正确，服务器就可以根据Range头计算偏移量，读取文件的片段了，返回状态码206 partial content，和200的意思差不多，但表示div只是原数据的一部分<br>
第三，服务器要添加一个响应头字段Content-Range，告诉片段的实际偏移量和资源的总大小，格式是bytes x-y/length，与Range头区别在没有“=”，范围后多了总长度<br>
多端段据<br>
上文解释的是如何进行的范围传输，是一个范围的，现在我们需要多个范围的传输，我们应该如何实现。<br>
这种情况需要使用一种特殊的MIME类型:multipart/byteranges，表示报文的div是由多段字节序列组成的，并且还要用一个参数boundary=xxx给出段之间的分隔标记。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两个协程交替打印奇偶数]]></title>
        <id>http://IseEkko.github.io/post/liang-ge-xie-cheng-jiao-ti-da-yin-qi-ou-shu/</id>
        <link href="http://IseEkko.github.io/post/liang-ge-xie-cheng-jiao-ti-da-yin-qi-ou-shu/">
        </link>
        <updated>2022-03-15T14:43:08.000Z</updated>
        <summary type="html"><![CDATA[<p>常见的go工程问题</p>
]]></summary>
        <content type="html"><![CDATA[<p>常见的go工程问题</p>
<!-- more -->
<h2 id="解析">解析</h2>
<p>在go语言中，开启一个协程是很容易的，直接使用的是go关键字，这里需要我们注意的时候，我们如何做到两个协程的同步，这个让我一下想到的就是channel，使用channel来完成这个功能，我们用一个使用go关键字开启两个协程，然后通过通信做到这个功能。<br>
也可以不使用channel，使用纯go 开启协程来做这个事情，这里涉及到的就是调度的问题，我们使用调度的方式，也就是当奇数进行打印的时候答应完一个就让出cpu的使用权限，然后偶数同理，但是这里我们需要注意的事情就是我们一定要设置使用的cpu核心数是多少。这里因为是两个交替打印所以我们使用到的就是一个核心数量就可以了。</p>
<h2 id="实现源码">实现源码</h2>
<p><img src="http://IseEkko.github.io//post-images/1647355474623.png" alt="" loading="lazy"><br>
<img src="http://IseEkko.github.io//post-images/1647355482241.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Keep-Alive 和非 Keep-Alice的差别]]></title>
        <id>http://IseEkko.github.io/post/keep-alive-he-fei-keep-alice-de-chai-bie/</id>
        <link href="http://IseEkko.github.io/post/keep-alive-he-fei-keep-alice-de-chai-bie/">
        </link>
        <updated>2022-03-15T14:41:05.000Z</updated>
        <summary type="html"><![CDATA[<p>这里的意思就是保持连接，和不保持连接</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里的意思就是保持连接，和不保持连接</p>
<!-- more -->
<h2 id="理解">理解</h2>
<p>我们如何来理解这个问题呢，keep-alive 和非 keep- alive的区别。其实是很好理解的，我们在非keep-alive中我们请求一个资源我们就要建立一个连接，keep-alive就很好理解了，下面我们通过一个图片来看理解一下。<br>
<img src="http://IseEkko.github.io//post-images/1647355356596.png" alt="" loading="lazy"></p>
<h2 id="区别与缺点">区别与缺点</h2>
<p>两者的区别和缺点，我们也很好的能通过上图看出来<br>
非Keep-alive<br>
我们每请求一个资源我们就要进行一个连接，然后我们创建一个连接是需要付出相应的成本的，建立一个连接，客户端和服务端都要分配一个TCP的缓冲区和变量这样会对服务器造成严重的负担。<br>
Keep-alive<br>
keep-alive很好的解决了上面的问题，也就是对于服务器严重的负担，但是他也不是完美的，因为保持连接，很可能造成资源的无效占用。这就是对资源的一种浪费。<br>
当然我们也有相应的解决办法，也就是我们需要正确的设置keepalive-timeout的时间，超过这个时间过后我们就断开连接，这样我们就可以解决资源无效占用的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见的五大基本类型（1）]]></title>
        <id>http://IseEkko.github.io/post/chang-jian-de-wu-da-ji-ben-lei-xing-1/</id>
        <link href="http://IseEkko.github.io/post/chang-jian-de-wu-da-ji-ben-lei-xing-1/">
        </link>
        <updated>2022-03-15T14:38:10.000Z</updated>
        <summary type="html"><![CDATA[<p>这里讲解的是string的使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里讲解的是string的使用</p>
<!-- more -->
<h2 id="redis-key的基本操作">Redis Key的基本操作</h2>
<pre><code>•    keys * 查看当前库中的所有key值
•  exists  key 判断key是不是存在
• type key 查看类型
• del key删除对应的值
• unlink key 也是删除对应的数据
• expire key 10 设置过期时间  
• Select index 就是切换库
• Dbsize 查看key的数量
• Flushdb 清空当前库
• Flushall 清空所有的库
</code></pre>
<h4 id="del-key-和unlink-key的区别">del key 和unlink key的区别</h4>
<p>del key是直接删除，到那时unlink key做的是异步的删除操作</p>
<h2 id="redis字符串-string">Redis字符串 string</h2>
<p>string是一个基本的类型，一个key对应一个value，string是二进制安全的，也就是说可以便是任意的数据，只要是可以转换为字符串，那么就可以存储，在redis中string最多可以存储512MB</p>
<h4 id="基本的操作">基本的操作</h4>
<p>set是添加的操作，set key value。<br>
get是查询操作，get key 就可以取出来了。<br>
这里需要注意的事情：如果我们set已经存在的值的时候，就会覆盖这个key的值<br>
Append 是在后面添加，也就是go中的添加切片的操作<br>
Strlen key 获取值的长度<br>
Setnx key value 这个时候是如果没有这个key的时候才存储这个值，如果库中有这个key那么久不会存储这个值。<br>
Incr key 这个操作是把数字类型进行一个加一操作<br>
Decr key 这个操作就是把数字类型进行一个减1<br>
Incrby key 步长 这个就是自定义加多少<br>
Decrby key 步长 就是定义减多少的意思。<br>
需要注意的事情：redis中的incr是原子操作<br>
mset 同时设置一个或者多个key-value进行操作<br>
Msetnx 如果包含库中有的key的时候就不会成功，这里需要知道有一个那么所有都会失败<br>
Getrange key 开始结束的位置 获取范围的值<br>
Setrange key 开始为位置 值 这样就会覆盖<br>
Set key 过期时间 value  这样可以在设置值的时候同时设置过期时间<br>
Ttl age 可以查看还有多久时间过期<br>
Getset key value 取出旧值然后覆盖值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重建二叉树]]></title>
        <id>http://IseEkko.github.io/post/chong-jian-er-cha-shu/</id>
        <link href="http://IseEkko.github.io/post/chong-jian-er-cha-shu/">
        </link>
        <updated>2022-03-15T14:29:57.000Z</updated>
        <summary type="html"><![CDATA[<p>这里讲解的是利用前序和中序遍历的结果重建二叉树</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里讲解的是利用前序和中序遍历的结果重建二叉树</p>
<!-- more -->
<h2 id="题目解析">题目解析</h2>
<p>我们首先要知道的是前序遍历和中序遍历是怎么遍历的。前序遍历是，首先处理中间节点，然后处理左右节点。中序遍历的遍历方式是首先遍历左节点然后遍历中左右节点。理解了这个过后我们就可以开始使用构造这个二叉树了。<br>
我们首先可以明白的是，前序遍历的第一个节点就是头节点，然后通过头结点找到它在中序遍历的位置，然后通过这个位置，我们可以知道的是，在这个节点的左边是左子树，右边是右子树，然后我们就知道了左子树的结点个数和右子树的结点个数，这个时候我们就可以开始递归。然后我们就可以得到这个二叉树。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="http://IseEkko.github.io//post-images/1647355074803.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树查找最近公共祖先]]></title>
        <id>http://IseEkko.github.io/post/er-cha-shu-cha-zhao-zui-jin-gong-gong-zu-xian/</id>
        <link href="http://IseEkko.github.io/post/er-cha-shu-cha-zhao-zui-jin-gong-gong-zu-xian/">
        </link>
        <updated>2022-03-14T15:03:38.000Z</updated>
        <summary type="html"><![CDATA[<p>这个题目的难度就是，我们不是搜索树了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个题目的难度就是，我们不是搜索树了。</p>
<!-- more -->
<h2 id="解题思路">解题思路</h2>
<p>这个题目我们需要想到的是，我们的思路还是差不多的，但是这里不能在用二叉搜索树的那个方法了，我们还是需要遍历，但是遍历的方式我们要进行改变。<br>
我们还是从根开始遍历，我们遍历到叶子节点了这个时候我们需要做的就是返回并判断，最终找到我们需要找到了节点，还是左右节点分开。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="http://IseEkko.github.io//post-images/1647270531026.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉搜索树的最近公共祖先]]></title>
        <id>http://IseEkko.github.io/post/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/</id>
        <link href="http://IseEkko.github.io/post/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/">
        </link>
        <updated>2022-03-14T14:43:49.000Z</updated>
        <summary type="html"><![CDATA[<p>二叉搜索树的最近公共祖先，理解这个题目的本质</p>
]]></summary>
        <content type="html"><![CDATA[<p>二叉搜索树的最近公共祖先，理解这个题目的本质</p>
<!-- more -->
<h2 id="题目解析">题目解析</h2>
<p>对于这个题目，解题的步骤从根节点进行遍历，因为我们知道是，二叉搜索树的特性，通过比较大小进行遍历，这样回更加的快速并且保持正确性，然后把左右节点的路径都找到过后我们就开始进行比较，当发现相同的时候，并且是最后一个相同的时候这个就是最近的公共祖先。<br>
这个理解起来不是很难，但是需要我们理解到位。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="http://IseEkko.github.io//post-images/1647270127652.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>