<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>isekko</title>
    <updated>2022-01-11T11:17:42.211Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>对个人笔记的总结，这个网站的笔记将会是我经过提炼过后的笔记。</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, isekko</rights>
    <entry>
        <title type="html"><![CDATA[gorm介绍]]></title>
        <id>https://IseEkko.github.io/post/gorm-jie-shao/</id>
        <link href="https://IseEkko.github.io/post/gorm-jie-shao/">
        </link>
        <updated>2022-01-11T11:03:42.000Z</updated>
        <summary type="html"><![CDATA[<p>gorm让我们从繁琐的sql中解脱出来，<br>
努力的学习gorm，但是也别忘记了sql是怎么写的</p>
]]></summary>
        <content type="html"><![CDATA[<p>gorm让我们从繁琐的sql中解脱出来，<br>
努力的学习gorm，但是也别忘记了sql是怎么写的</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1641899816277.png" alt="" loading="lazy"></figure>
<h1 id="gorm">GORM</h1>
<p>这里不是我第一次学习gorm，只是这次想具体的去学习一下这个gorm，因为我的sql能力很弱，在写项目的时候清楚的看到了自己的不足，还有就是对gorm使用的不足，这里最关键的就是我其实对sql学得不是很好，后面还要更新对sql的学习，越到后面越发现这基础的重要性。</p>
<h1 id="什么是gorm">什么是GORM</h1>
<p>gorm就是go中封装的一种orm，orm对象关系映射，对于我们理解来说，就是一个为了让我们更好的操作数据库的一个工具。<br>
下面我把官网放在下面。<br>
<a href="https://gorm.io/zh_CN/docs/index.html">GORM官网中文文档</a></p>
<h1 id="对于gorm的感觉">对于GORM的感觉</h1>
<p>其实对于这个gorm呢，在开发的时候确实速度是很快的，我们不用过多的在意sql是怎么写的。但是这样会弱化我们对sql的理解，所以我们觉得这个东西对于我们大学生来说，我认为我们写每一个方法的时候，我们多在意一下它生成的sql这样，我们不会弱化了我们对sql的理解。<br>
当然了。我的sql很菜，我还是字学习gorm的时候，好好的学习一下sql，系统的学习一下。</p>
<p>上面就是我给大家分享的gorm，下面我将会更新gorm中使用的细节。<br>
有那里写的不好的地方，希望大家多指教指教。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[平衡二叉树]]></title>
        <id>https://IseEkko.github.io/post/ping-heng-er-cha-shu/</id>
        <link href="https://IseEkko.github.io/post/ping-heng-er-cha-shu/">
        </link>
        <updated>2022-01-11T07:34:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1641891619971.png" alt="" loading="lazy"></figure>
<h1 id="题目">题目</h1>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>示例 1：<br>
 <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="" loading="lazy"></p>
<p>输入：root = [3,9,20,null,null,15,7]<br>
输出：true<br>
示例 2：<br>
 <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="" loading="lazy"></p>
<p>输入：root = [1,2,2,3,3,null,null,4,4]<br>
输出：false<br>
示例 3：</p>
<p>输入：root = []<br>
输出：true</p>
<h1 id="思路">思路</h1>
<p>题目很简单，思路也很清晰，也就是我们去看树的高度差不大于1.我们只要依据这个条件去写代码就可以了</p>
<h1 id="解题">解题</h1>
<pre><code>func isBalanced(root *TreeNode) bool {
if root == nil{
    return true
}
if (!isBalanced(root.Left)||!isBalanced(root.Right)){
    return false
}
Left := getDepath(root.Left)+1
Right := getDepath(root.Right)+1
if (abs(Left-Right)&gt;1){
    return false
}
return true
}

func getDepath(root *TreeNode)int{
    if root == nil{
        return 0
    }
    return max(getDepath(root.Left),getDepath(root.Right))+1
}
func max(left,right int)int{
    if left &gt;right{
        return left
    }
    return right
}
func abs(num int)int{
if num&lt;0{
    return -num
}
return num
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最小深度]]></title>
        <id>https://IseEkko.github.io/post/er-cha-shu-de-zui-xiao-shen-du/</id>
        <link href="https://IseEkko.github.io/post/er-cha-shu-de-zui-xiao-shen-du/">
        </link>
        <updated>2022-01-11T07:01:46.000Z</updated>
        <summary type="html"><![CDATA[<p>对于二叉树最小深度的解题相关，包含源码</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于二叉树最小深度的解题相关，包含源码</p>
<!-- more -->
<h1 id="题目">题目</h1>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<!-- more -->
<p>说明：叶子节点是指没有子节点的节点。</p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="avatar" loading="lazy"></figure>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>
输出：2<br>
示例 2：</p>
<p>输入：root = [2,null,3,null,4,null,5,null,6]<br>
输出：5</p>
<h1 id="思路">思路</h1>
<pre><code> 对于这个题目，最开始我是没有什么思路的，后面去看了解析才知道怎么写到。这里把之前看到的进行一个总结。
  这个题目的主要思想就是后序遍历，后序遍历就是对树的中间节点进行最后的操作。
</code></pre>
<h1 id="解题源码">解题源码</h1>
<pre><code>func minDepth(root *TreeNode) int {
  return getDepth(root)
}

func getDepth(root *TreeNode)int{
    if root == nil{
        return 0
    }
    left := getDepth(root.Left)
    right := getDepth(root.Right)
    if (root.Left ==nil&amp;&amp;root.Right != nil){
        return right+1
    }
    if (root.Left != nil&amp;&amp; root.Right == nil){
        return left+1
    }
    return 1+min(left,right)
}
func min(left,right int)int{
    if left&lt;right{
        return left
    }
    return right
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最大深度]]></title>
        <id>https://IseEkko.github.io/post/er-cha-shu-de-zui-da-shen-du/</id>
        <link href="https://IseEkko.github.io/post/er-cha-shu-de-zui-da-shen-du/">
        </link>
        <updated>2022-01-10T13:36:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><img src="https://IseEkko.github.io//post-images/1641825317112.png" alt="" loading="lazy"># 题目<br>
给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>  3
/  \
</code></pre>
<p>9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3</p>
<!-- more -->
<h1 id="思考">思考</h1>
<p>拿到这个题目我们最先想到的就是层序遍历，为什么呢？<br>
我们首先要明白层序遍历我们最后的结果是什么，层序遍历我们最后得到的是一个二位数组。<br>
那我们换个角度去看他，最大的深度是不是就是层序遍历最后二维数组的层数。答案是肯定的。<br>
上面是我最先能使用的方法。</p>
<h1 id="解题">解题</h1>
<p>这里解题的方式有两种</p>
<h2 id="递归法">递归法</h2>
<p>这里我们回顾一下递归的三个要素。根据三要素来书写代码。<br>
1. 确定输入和返回值<br>
2. 确定终止条件<br>
3. 确定单层逻辑<br>
那么下面我们来详细的书写一下代码<br>
首先我们确定输入和返回值，这里我们首先输入的肯定是节点，然后返回的是深度</p>
<pre><code> function fun(){
    func getDepths(root *TreeNode) int
 }
 fun();
</code></pre>
<p>第二步是确定终止的条件，这里我们终止的条件是节点是nil<br>
if root ==nil{<br>
return 0<br>
}<br>
第三步确定单层的逻辑<br>
Left := getDepths(root.Left)<br>
Right := getDepths(root.Right)<br>
deth := 1 + max(Left,Right)<br>
这里需要注意的是，我们最后得到的是高度，这里的高度是需要加一的。</p>
<p>最后的源码：</p>
<pre><code>func maxDepth(root *TreeNode) int {
   return getDepths(root)
}

func getDepths(root *TreeNode) int{
    if root ==nil{
        return 0
    }
    Left := getDepths(root.Left)
    Right := getDepths(root.Right)
    deth := 1 + max(Left,Right)
    return deth
}

func max(Left,Right int)int{
    if Left &gt; Right{
        return Left
    }
        return Right
}
</code></pre>
<h3 id="迭代法">迭代法</h3>
<p>这个方法也就是我之前想到的那个方法，也就是使用层讯遍历去完成这个题目，这里我们就不在过多的解析<br>
在后面的层序遍历的地方我会把这段代码详细的解析一遍。</p>
<pre><code>func maxDepth(root *TreeNode) int {
    var res [][]int
    if root == nil{
        return 0
    }
    st:= list.New()
    st.PushBack(root)
    var Arrtem []int
    for st.Len() &gt; 0{
        lenth := st.Len()
        for i := 0;i&lt;lenth;i++{
            node := st.Remove(st.Front()).(*TreeNode)
            if node.Left != nil{
                st.PushBack(node.Left)
            }
            if node.Right != nil{
                st.PushBack(node.Right)
            }
            Arrtem = append(Arrtem,node.Val)
        }
        res  = append(res,Arrtem)
        Arrtem = []int{}
    }
    result := len(res)
  return result
}

</code></pre>
]]></content>
    </entry>
</feed>