<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>BytesLzz</title>
    <updated>2022-03-25T00:36:40.339Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>做好每一件事，读好每一本书，天道酬勤</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, BytesLzz</rights>
    <entry>
        <title type="html"><![CDATA[数组内部实现和基本使用]]></title>
        <id>https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/</id>
        <link href="https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/">
        </link>
        <updated>2022-03-24T11:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>了解go数组的细节</p>
<h2 id="数组的内部实现和基础功能">数组的内部实现和基础功能</h2>
<p>在go中数组是一个长度固定的数据类型，用于存储具有相同类型的元素的连续块。因为存储的空间是连续的，所以遍历和查找元素也是很方便和简单的。</p>
<h3 id="声明和初始化">声明和初始化</h3>
<p>一旦声明了数组的长度和数组类型那么久不能在改变了，在go中数组的长度和类型也是类型的判断属性。只有两个属性相同的时候才能判定这个两个数组相同。</p>
<h3 id="初始化">初始化</h3>
<p>第一种：声明一个数组，并设置为零值<br>
var array [5]int<br>
第二种：使用数组字面量声明数组<br>
array := [5]int{1,2,3,4,5}<br>
第三种：让go自动计算声明数组长度<br>
array ：= […]int{1,2,3,4,5}<br>
第四种：声明数组并指定特定元素的值<br>
array  := [5]int{1:10,2:20}</p>
<h2 id="使用数组">使用数组</h2>
<p>因为数组的地址空间是连续的，所以数组的效率是很高的。如果要访问数组中的某个元素，使用【】加上下标就可以进行访问。<br>
使用指针类型的数组的时候，里面存放的是地址。把一个指针数组赋值给另一个指针数组，这个时候这两个数组中存放的地址是相同的，也就是指向的同一个地址空间。</p>
<h2 id="多维数组">多维数组</h2>
<p>数组本身只有一个纬度，不过可以组合多个数组创建多位数组。这里就不再多说多位数组的相关知识了。</p>
<h2 id="在函数间传递数组">在函数间传递数组</h2>
<p>在go中传递一个值，都是以类型的方式进行传输的，也就是说传递一个数组，会复制一个完整的数组进行传输，也就是说无论数组多大我们都会进行数组的全复制然后进行传输。<br>
这样的话我们就会损失效率，我们解决的办法就是使用指针类型进行传输。这个时候传输复制的时候就只用复制8字节的指针类型了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NAT地址转换]]></title>
        <id>https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/</id>
        <link href="https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/">
        </link>
        <updated>2022-03-24T00:08:35.000Z</updated>
        <content type="html"><![CDATA[<p>NAT地址转换它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。<br>
实现的三种方法</p>
<h2 id="三种实现方法有利有弊">三种实现方法有利有弊</h2>
<h3 id="第一种">第一种</h3>
<p>静态地址转换，内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可网络对内部网以实现外部络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p>
<h3 id="第二种">第二种</h3>
<p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p>
<h3 id="第三种">第三种</h3>
<p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARP协议]]></title>
        <id>https://IseEkko.github.io/post/arp-xie-yi/</id>
        <link href="https://IseEkko.github.io/post/arp-xie-yi/">
        </link>
        <updated>2022-03-24T00:08:05.000Z</updated>
        <content type="html"><![CDATA[<p>ARP协议是一个mac地址和IP地址的一个映射关系，也就是系统通过ip找到他的mac地址。<br>
过程</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿数量]]></title>
        <id>https://IseEkko.github.io/post/dao-yu-shu-liang/</id>
        <link href="https://IseEkko.github.io/post/dao-yu-shu-liang/">
        </link>
        <updated>2022-03-22T15:09:58.000Z</updated>
        <content type="html"><![CDATA[<p>今天做了一个题目就是关于一个二维数组。</p>
<h2 id="题目解析">题目解析</h2>
<p>在这个题目里面，我们需要做的是判断岛的数量，在这里1表示的是岛屿，0表示的是海洋，相邻的1表示的是一个岛屿。然后看到这里，我们就想到了我们要使用的方法，就是遍历然后计算1的位置。<br>
如何判断相邻的1是一个岛屿，使用的就是dfs广度优先算法。</p>
<h2 id="解析源码">解析源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647961967703.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全排列问题]]></title>
        <id>https://IseEkko.github.io/post/quan-pai-lie-wen-ti/</id>
        <link href="https://IseEkko.github.io/post/quan-pai-lie-wen-ti/">
        </link>
        <updated>2022-03-21T15:16:30.000Z</updated>
        <content type="html"><![CDATA[<p>今天遇见的题目是全排列的问题，这里进行一个总结<br>
<img src="https://IseEkko.github.io//post-images/1647875887964.png" alt="" loading="lazy"><br>
题目解析<br>
今天进行全排列的解析，给一个数组，然后进行排列组合，给出最后所有的排列组合。有一定的经验所以我们可以画出下面这个图<br>
<img src="https://IseEkko.github.io//post-images/1647875897982.png" alt="" loading="lazy"><br>
这里我们可以很清楚的看到，这里使用的方式是回溯，那么我们就可以开始写这个代码了。<br>
这个题目在做的时候，我们使用到的是slice的一些方法，删除第k个元素，然后加入第k个元素。<br>
达到回溯的效果。<br>
解题源码<br>
<img src="https://IseEkko.github.io//post-images/1647875924078.png" alt="" loading="lazy">		<br>
稍微加一点难度就是这个数组是无序的有重复的数组。<br>
这个时候在循环的时候就要判断数组中重复的数字。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路由器和交换机的区别]]></title>
        <id>https://IseEkko.github.io/post/lu-you-qi-he-jiao-huan-ji-de-qu-bie/</id>
        <link href="https://IseEkko.github.io/post/lu-you-qi-he-jiao-huan-ji-de-qu-bie/">
        </link>
        <updated>2022-03-21T15:15:55.000Z</updated>
        <content type="html"><![CDATA[<p>路由器和交换机，他们位于不同的位置，<br>
交换机处于网络中的数据链路层，根据mac地址进行转发，一般用于构建简单的内部网络<br>
路由器，路由器是在网络层中进行工作的，根据的是ip地址进行转发的。一般用于构建复杂的网络。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路由转发]]></title>
        <id>https://IseEkko.github.io/post/lu-you-zhuan-fa/</id>
        <link href="https://IseEkko.github.io/post/lu-you-zhuan-fa/">
        </link>
        <updated>2022-03-21T15:11:49.000Z</updated>
        <summary type="html"><![CDATA[<p>在网络传输的过程中，会经过很多的路由，那么我们如何进行转发的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在网络传输的过程中，会经过很多的路由，那么我们如何进行转发的呢？</p>
<!-- more -->
<h2 id="流程">流程</h2>
<p>在传输的过程中，路由需要做的，就是把数据包传输到他该去的地方，在如今的网络中，已经有很多且复杂的网络。这个时候我们需要做的是什么呢。<br>
首先从ip数据包中提取出目的主机的io地址，然后找到他所在的网络。<br>
这个时候判断ip所在的网络是不是和本路由直接相连，如果是那么就直接进行转发。<br>
如果不是，路由会检查路由表，看路由表中是不是有ip地址的特定主机路由，如果有那么就直接跳转到下一跳路由中去。<br>
如果我们没有找到对应的特定主机，路由器会检查路由表，使每一行的子网掩码与目的的ip匹配，如果找到了，则按照路由表转发下一跳路由中<br>
如果没有找到，就按照默认的路由转发到默认路由中，不然无法找到路由那么就向源主机报错。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三月二十号-周总结]]></title>
        <id>https://IseEkko.github.io/post/san-yue-er-shi-hao-zhou-zong-jie/</id>
        <link href="https://IseEkko.github.io/post/san-yue-er-shi-hao-zhou-zong-jie/">
        </link>
        <updated>2022-03-20T05:27:33.000Z</updated>
        <content type="html"><![CDATA[<p>一周过去了，在周末把这个星期的收获总结一遍。</p>
<h2 id="计算机网络">计算机网络</h2>
<p>本周对计算机网络进行了一定的学习，主要学习的范围是应用层和传输层。</p>
<h3 id="应用层">应用层</h3>
<h4 id="keep-alive和非keep-alive">keep-alive和非keep-alive</h4>
<p>在应用层中，我们主要要学习的东西是http协议相关的知识，本周对http协议也有了新的一个认识，首先我们来看一下http协议。<br>
http协议是我们在做web应用的一个协议，他是一个请求/响应式的一种协议，也就是发起请求然后等待一个响应。说到请求和响应我们就想到了我们首先要建立连接，在http中建立的是tcp协议，在http的演进中这个连接的方式发生了改变，在http1.1前使用的是非长连接方式，在这个连接方式中也就是为每一个请求建立一个tcp连接。然后我们知道的是TCP建立一个连接会消耗很多的资源，所以从速度上来说就慢了许多，后面我们会细说TCP连接的三个握手和四次挥手。这里下面我们放一张图也就是长连接和非长连接的示意图：<br>
<img src="https://IseEkko.github.io//post-images/1647762950584.png" alt="" loading="lazy"><br>
但是这个两个方式都是优缺点的，第一个非长连接的缺点很明显当很多人进行访问的时候这个时候对于服务器的压力是很多的，然后第二个长连接就是保持连接的时间如果时间不合理也会让服务器的资源被无效的占用。这个问题我们解决的办法就是正确的设置keepalive-timeout的时间。</p>
<h4 id="如何知道http协议传输的报文长度">如何知道http协议传输的报文长度</h4>
<p>对于小文件来说，服务器会直接在响应报文的content-Lenth字段上写上<br>
对于大文件来说，在http1.1以后用的方式是分块传输，这个时候客户端只会知道进行的是分块传输，是通过Transfer-Encoding：chunked字段，这里我们要知道不会传输数据的长度，每一个包会包含一个十六进制的长度值和数据，最后一个分块长度是0，表示实体的结束，客户端可以根据这个确认数据接收完成。</p>
<h4 id="大文件的传输方式">大文件的传输方式</h4>
<p>对于大文件我们有几种传输方式分别是：数据压缩、分块传输、范围请求、多段数据请求<br>
对于这四种方式适用的地方是不一样的，首先我们先来说一下数据压缩，<br>
对于数据压缩来说，很简单就是选择一个压缩算法，然后对数据进行压缩然后进行传输，我们都知道压缩完的数据是变小了的，这里我们有一个问题，我们如何选择算法，根据什么呢？<br>
压缩算法的选择看得是Transfer-Encoding：chunked字段，在这个字段里面我们可以知道浏览器支持的压缩算法，然后服务端会对比自己支持的算法然后进行选择。但是这个传输方式的缺点是很明显的，对于文本文件是没有问题的，但是呢我们要知道对于图片和视频文件来说，我们知道要知道的是这些文件都是经过高度压缩了的，所以压缩算法对于他来说是无效的。<br>
分块传输，我们将大文件拆分成小文件进行传输，这样的话我们的网络中就不会占用过多的时间可以节省服务的资源。详细的内容请查看以前的博客。<br>
范围请求，我们在观看视频的时候，很多时候需要进行快进，那么我们如何办到呢。我们使用到的技术就是范围请求。在http中有一个range字段，因为在http中这个功能可有可无的，所以我们要通过Accept-Ranges:bytes明确告知客户端：我是支持范围请求的。<br>
多段数据进行传输，这种情况需要使用一种特殊的MIME类型:multipart/byteranges，表示报文的div是由多段字节序列组成的，并且还要用一个参数boundary=xxx给出段之间的分隔标记。</p>
<h4 id="http协议不同版本之间的区别">http协议不同版本之间的区别</h4>
<p>1.0和1.1的区别<br>
• 缓存处理：<br>
1.1较1.0相比缓存的策略更加的灵活<br>
• 节约带宽：<br>
在1.1中添加了range字段，可以请求资源的部分内容，这使得开发者可以线程的请求某一资源。从而重新的利用带宽资源进行高效的并发<br>
• 错误请求的管理：<br>
1.1较1.0新增了24个状态码<br>
• Host 请求头：<br>
早期的服务器，都是一个机器处理单一的任务，所以可以直接用ip进行标识，但是后面有了虚拟机过后，一个主机可以有多个虚拟机，然后这个时候我们为了支持这个虚拟主机，1.1就增加了host请求头<br>
• 长连接：<br>
HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。<br>
1.x和2.0 的区别<br>
• 二进制传送：<br>
之前版本 数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有场景； 2.0传送的是二进制，相当于统一了格式<br>
• 多路复用：<br>
1.1虽然默认复用TCP连接，但是每个请求是串行执行的，如果前面的请求超时，后面的请求只能等着（也就是线头阻塞）； 2.0的时候每个请求有自己的ID，多个请求可以在同一个TCP连接上并行执行，不会互相影响<br>
• header压缩：<br>
每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编号就行，用的时候只需要拿着编号去表里查找就行，<br>
减少了传输的数据量<br>
• 服务端推送：<br>
服务器会在客户端没发起请求的时候主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html页面相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接从缓存中获取，就不需要再发起请求了</p>
<h4 id="dns的作用和原理">DNS的作用和原理</h4>
<p>在网络的世界里面，我们看着文字的符号便于记忆，但是对于计算机来说有规律的数字更好的理解，然后就有了DNS。理解就是一个分布式的数据库，然后要找主机我们就更具域名进行查询。</p>
<h3 id="传输层">传输层</h3>
<p>学习完了应用层的基本内容后我们进入了传输层的学习，传输层也就是对数据进行传输的地方，这里主要讲解的就是TCP传输协议的知识，我们知道它是可靠的数据传输方式，这个要归功于rdt机制，对传输的数据进行确认后再发送后面的数据加上重传机制，保证了TCP的可靠传输。</p>
<h4 id="tcp连接是如何进行连接的">TCP连接是如何进行连接的</h4>
<p>TCP的连接的过程，也就是我们以前常说的三次握手，那么这个三次握手的过程是怎么样的呢。<br>
<img src="https://IseEkko.github.io//post-images/1647762973573.png" alt="" loading="lazy"><br>
上图中很好的展示了TCP三次握手的过程，在这里面我们需要注意的点是，在三次握手中，第一次和第二次握手是不携带数据传输的，但是要占用序号位，第三次握手时候可以包含数据，但是这里不一样的是，携带了数据就要占用序号位，如果没有数据传输那么就不会进行序号位的占用。<br>
####为什么是三次握手不是两次呢<br>
在TCP中第一次握手时候是客户端发起的请求，然后为了确保数据的可靠，那么我们就要进行数据的确认，第二次握手的时候我们对第一次握手的数据进行了确认，但是第二次握手的数据没有得到确认那么这个方式就是不可靠的，比如说我们进行第二次握手的时候，其实根本没有收到ack数据包进行第一次握手的确认，那么当客户端进行再次确认的时候，又会进行第一次握手的操作，然后服务端再一次进行ack确认报文的发送，那么对于客户端来说就只有一个连接，但是对于服务端来说就两个连接，这样的数据传输就没有可靠性的。所以我们要进行三次握手而不是两次。</p>
<h4 id="保证数据的可靠性">保证数据的可靠性</h4>
<p>TCP是全双工的信道，如何避免乱序和丢包问题呢？在TCP协议中，我们之前说了一下他是传输一个数据等待确认后再进行后面的传输。<br>
这里我们详细的讲解一下，在TCP传输的过程中会建立一个发送端缓存区，然后截取数据的一部分，然后加上序列号、长度、数据内容然后进行传输，传输后会等待一个确认的报文，ack就是传输确认的报文，也就是ack报文，这个报文包含什么那些东西呢？ACK = 序列号 + 长度 = 下一个起始序列号。这样就保证了数据的可靠性。<br>
<img src="https://IseEkko.github.io//post-images/1647762983716.png" alt="" loading="lazy"></p>
<h4 id="tcp拥塞控制采取的四种算法">TCP拥塞控制采取的四种算法</h4>
<p>TCP传输不仅数据传输可靠，而且在传输在时候会更具网络的状况进行流量的管控。这里我们就简单的说一下这四种算法</p>
<h5 id="慢开始">慢开始</h5>
<p>在网络中我们不知道网络中的通信状态，这个时候TCP会发送一个很小的数据包进行通道的侦测，然后慢慢的增加窗口的大小。</p>
<h5 id="拥塞避免">拥塞避免</h5>
<p>这里我们为了拥塞窗口的缓慢增大，每经过一个RTT，我发送窗口就会加一。<br>
当网络的拥塞发生的时候，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p>
<h5 id="快恢复">快恢复</h5>
<p>快恢复算法，和快重传算法是配合使用的，连续接收到三次确认后，会减半阀值，,窗口长度起点和阙值一样，执行拥塞避免，线性递增</p>
<h5 id="快重传">快重传</h5>
<p>当接收方接收到一个失序的数据包的时候马上进行重传。我们假设有四个数据包，分别是1，2，3，4，然后我们这里接收到的是1，3，4。这个时候发送端一直接收到的是数据包一的确认包，然后这个接收到三次1的确认后，我们就会立即重新传输对方没有接收到的报文。由于发送发尽快发送没有接收到的报文段，所以快速重传会提高网络的吞吐量。</p>
<h4 id="tcp断开连接的过程">TCP断开连接的过程</h4>
<p>上面我们对TCP连接的建立和传输中遇见的问题解决办法，进行了一次总结，然后下面我们说一下TCP连接的断开，也就是四次挥手的过程，在四次挥手的过程中也有我们需要注意的地方。首先我们先看一下整个过程的流程图。<br>
<img src="https://IseEkko.github.io//post-images/1647762278280.png" alt="" loading="lazy"><br>
在这里我们需要知道的是在最后的时候发起断开连接的端，会进行一个等待后才会关闭。我们要等待这个时间呢？<br>
等待这个时间其实是为了等待最后确认的ack到达没有到达接收端，因为如果没有接收到，接受端会再次发送fin包进行最后的确认。</p>
<h2 id="redis">Redis</h2>
<p>本周只学习了redis的一个很小的部分，就是string类型。<br>
一些基本的操作详细请看之前发的博客。</p>
<h2 id="go工程问题">Go工程问题</h2>
<p>在这周海子给我说了一下在面试经常面的问题，这里有一个问题就是对协程的使用，就是对协程的使用，使用两个协程进行交替打印奇偶数字。<br>
<img src="https://IseEkko.github.io//post-images/1647762593057.png" alt="" loading="lazy"><br>
<img src="https://IseEkko.github.io//post-images/1647762605452.png" alt="" loading="lazy"><br>
上面是两种解法，在看这里的时候直接看代码就像理解就可以了。</p>
<h3 id="go秒杀">Go秒杀</h3>
<p>本周开始秒杀系统的书写在本次开发中会把问题记录得很细致，每一个知识点都会有记录，这里对本周的学习进行一个总结。</p>
<h4 id="rabbitmq">RabbitMQ</h4>
<p>本周对系统的准备主要学习的RabbitMQ消息队列的使用和几个模式的书写。<br>
每种模式的书写可以查看之前的博客更加的细致。也更好的理解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP拥塞控制采取的四种算法]]></title>
        <id>https://IseEkko.github.io/post/tcp-yong-sai-kong-zhi-cai-qu-de-si-chong-suan-fa/</id>
        <link href="https://IseEkko.github.io/post/tcp-yong-sai-kong-zhi-cai-qu-de-si-chong-suan-fa/">
        </link>
        <updated>2022-03-19T05:52:42.000Z</updated>
        <content type="html"><![CDATA[<p>在TCP拥塞控制中，那么他在是怎么进行的的呢，一共是四个算法。</p>
<h2 id="慢开始">慢开始</h2>
<p>在一开始的时候，TCP不知道网络现在的状态就会先发送一个小的数据包进行传输，用来侦测网络的状态，然后慢慢的增加窗口的长度。<br>
在这里我们就有一个问题，也就是说，我们的窗口肯定不是无限在增长的，然后在增长的过程中，我们肯定是要做限制的，这个限制就是：ssthresh。</p>
<h2 id="拥塞避免">拥塞避免</h2>
<p>这里我们为了让拥塞窗口缓慢的增大，每经过一个RTT，发送方的拥塞窗口就会进行加一，然后这个时候窗口就会进行线性的增长。<br>
在网络拥塞发生的时候，让新的慢开始门限变为发生拥塞时候的一半，，并将拥塞窗口置为1，然后再次重复两种算法（慢开始和拥塞避免），这个时候一瞬间会将网络中的数据量大量的降低。</p>
<h2 id="快重传">快重传</h2>
<p>当接受方收到一个失序的数据包的时候，马上进行重传，我们假设没有四个数据包，分别是1，2，3，4，然后我们接收到了1，3，4。这个时候接受端会发送确认包，当发送端接收到三次一的确认的时候我们，就会立即传输没有接收到的数据包。</p>
<h2 id="快恢复">快恢复</h2>
<p>快恢复算法和快重传算法是配合使用的，连续接收到三次确认后会减半阀值，窗口长度和阀值一样，执行拥塞避免，线性递增。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Topic话题模式]]></title>
        <id>https://IseEkko.github.io/post/topic-hua-ti-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/topic-hua-ti-mo-shi/">
        </link>
        <updated>2022-03-18T01:24:09.000Z</updated>
        <summary type="html"><![CDATA[<p>我觉得是路由模式的升级版。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我觉得是路由模式的升级版。</p>
<!-- more -->
<h2 id="解析">解析</h2>
<p>对于这个模式，我觉得就是对路由模式的升级，在路由模式中，我们可以根据配置的路由进行消费者的发送，然后这里是通过配置符号进行消费者的发送，这里有可能我们用到的是给多个消费者进行发送。</p>
<h2 id="示意图">示意图</h2>
<p><img src="https://IseEkko.github.io//post-images/1647617723443.png" alt="" loading="lazy"><br>
这个模式的实例创建是和路由模式是相同的，进行路由名称和交换机模式的传输，通过这两个进行实例的创建。<br>
消息的处理<br>
这里无论是生产和消费消息，和路由模式的区别就是在交换机创建时候的kind的选择<br>
<img src="https://IseEkko.github.io//post-images/1647617735245.png" alt="" loading="lazy"><br>
然后在使用的时候，#代表的就是所有，然后*代表的是占位的意思。<br>
这个主要是仔细看一下案例就可以。</p>
]]></content>
    </entry>
</feed>