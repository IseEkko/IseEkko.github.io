<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>BytesLzz</title>
    <updated>2022-04-08T05:19:30.405Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>做好每一件事，读好每一本书，天道酬勤</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, BytesLzz</rights>
    <entry>
        <title type="html"><![CDATA[三数之和]]></title>
        <id>https://IseEkko.github.io/post/san-shu-zhi-he/</id>
        <link href="https://IseEkko.github.io/post/san-shu-zhi-he/">
        </link>
        <updated>2022-04-08T05:17:18.000Z</updated>
        <content type="html"><![CDATA[<p>三数之和，这个题目做过了很多次但是还是有点不清楚，今天重新做了一下。</p>
<h2 id="题目解析">题目解析</h2>
<p>这个题目理解起来还是很简单的，也就是在一个数组里面我们将三个数字加起来等于0那么记录一下就可以了，所以最后的输出肯定是一个二维数组。首先我们要做的事情就是找出来这些数字。<br>
这里我们使用迭代的方式，我们首先将数组进行排序，然后使用双指针的方式将数字找出来，首先我们先取出一个数字，然后我们就将一个三个数字的题目转换成一个两个数字的题目。<br>
然后我们在找两个数字的时候，因为我们的数组是进行了排序的，所以我们就将情况分解出来，也就是说如果最后三个数字的和大于零那么就是说明右边界太大了，那么我们就调整右边界，同理我们可以调整左边界。<br>
这里需要注意一个点，也就是我们在最后的结构，我们不要重复的，所以相同的数字我们就要将它排除，这里我们有三段代码做了这件事情。</p>
<h2 id="解题源码">解题源码</h2>
<pre><code>func threeSum(nums []int) [][]int {
  sort.Ints(nums)
  return TreeNum(nums)
}


func TreeNum(nums []int)[][]int{
   res := make([][]int,0)
   for i := 0;i&lt;len(nums)-2;i++{
       n1 := nums[i]
       if n1 &gt; 0{
           break
       }
       if i &gt; 0 &amp;&amp; n1 == nums[i-1]{
           continue
       }

       l,r := i+1,len(nums)-1
       for l &lt; r{
                n2 ,n3 := nums[l],nums[r]
                if n1+n2+n3 == 0 {
                    res = append(res,[]int{n1,n2,n3})
                    for l&lt;r &amp;&amp; nums[l] == n2{
                        l++
                    }
                    for l&lt;r &amp;&amp; nums[r] == n3{
                        r--
                    }
                }else if n1+n2+n3 &lt; 0{
                    l++
                }else{
                    r--
                }
       }
   }
   return res
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语言并发-订阅者模式]]></title>
        <id>https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/">
        </link>
        <updated>2022-04-07T07:44:39.000Z</updated>
        <content type="html"><![CDATA[<p>在之前的学习中，接触到了消息队列的一些知识，然后今天在看书的时候，发现了一个使用go channel完成了一个订阅者模式的并发demo。</p>
<h2 id="订阅者模式">订阅者模式</h2>
<p>关于订阅者模式，在这里给大家讲解一下，订阅者模式其实就是将产生的消息，给多个订阅者，然后订阅者可以看到这里订阅的消息。<br>
这里实现的时候呢，因为有并发的知识，所以我们用到了协程，下面我们来具体的实现一下。</p>
<h2 id="具体的实现流程">具体的实现流程</h2>
<h3 id="创建订阅者结构">创建订阅者结构</h3>
<pre><code>type (
	subscriber chan interface{}         //订阅者的通道
	topicFunc  func(v interface{}) bool //主题过滤器
)

//发布者对象
type Publisher struct {
	m           sync.Mutex               //读写锁
	buffer      int                      //订阅队列缓存大小
	timeout     time.Duration            //发布者超时时间
	subscribers map[subscriber]topicFunc //订阅者消息
}
</code></pre>
<p>上面我们定义了基本的订阅者的结构，上面也有对订阅者字段的解释，这里着重理解的东西就是：</p>
<pre><code>subscribers map[subscriber]topicFunc //订阅者消息
</code></pre>
<p>这个结构其实就是订阅者模式的一个重要的结构，这里存放的是订阅者的过滤器，也就是通过这个结构我们可以清楚的知道，订阅者订阅的是那个主题。</p>
<h3 id="构造函数">构造函数</h3>
<p>使用构造函数构造出订阅者的实体，然后进行后面的操作</p>
<pre><code>func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		buffer:      buffer,
		timeout:     publishTimeout,
		subscribers: make(map[subscriber]topicFunc),
	}
}
</code></pre>
<h3 id="添加订阅者信息">添加订阅者信息</h3>
<pre><code>//订阅全部，也就是不加入过滤器
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

//添加一个订阅者，同时订阅者是有过滤器的
//这里其实就是返回一个订阅者的信息，然后添加上过滤器
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}
</code></pre>
<p>这里就是添加订阅者，这里添加的时候添加订阅者的过滤器，也就是增加一个映射关系。</p>
<h3 id="添加主题">添加主题</h3>
<pre><code>//发布一个主题
func (p *Publisher) Publish(v interface{}) {
	p.m.Lock()
	defer p.m.Unlock()
	var wg sync.WaitGroup
	//这里返回的是订阅者，然后后面是返回的过滤器
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.sendTopic(sub, topic, v, &amp;wg)
	}
	wg.Wait()
}

//发布主题，可以容忍一定的超时
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}
	select {
	case sub &lt;- v:
	case &lt;-time.After(p.timeout):
	}
}
</code></pre>
<p>这里我们使用到的并发式的添加消息，这里使用到了sync.WaitGroup，进行协程的同步。</p>
<h3 id="关闭订阅者模式">关闭订阅者模式</h3>
<pre><code>//关闭发布对象，同时关闭
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()
	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}
</code></pre>
<h2 id="最后的测试">最后的测试</h2>
<pre><code>func main() {
	p := NewPublisher(100*time.Millisecond, 10)
	defer p.Close()
	all := p.Subscribe()
	golang := p.SubscribeTopic(func(v interface{}) bool {
		if s, ok := v.(string); ok {
			return strings.Contains(s, &quot;golang&quot;)
		}
		return false
	})
	p.Publish(&quot;hello,lzz&quot;)
	p.Publish(&quot;hello,golang&quot;)
	go func() {
		for msg := range all {
			fmt.Println(&quot;all:&quot;, msg)
		}
	}()
	go func() {
		for msg := range golang {
			fmt.Println(&quot;golang:&quot;, msg)
		}
	}()
	time.Sleep(3 * time.Second)
}
</code></pre>
<p>最后的输出结果：<br>
<img src="https://IseEkko.github.io//post-images/1649321380937.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打印齿形的二叉树层序遍历]]></title>
        <id>https://IseEkko.github.io/post/da-yin-chi-xing-de-er-cha-shu-ceng-xu-bian-li/</id>
        <link href="https://IseEkko.github.io/post/da-yin-chi-xing-de-er-cha-shu-ceng-xu-bian-li/">
        </link>
        <updated>2022-04-06T15:16:26.000Z</updated>
        <content type="html"><![CDATA[<p>层序遍历是一个很常见的一个算法结构，这里我们进一步的进行二叉树的学习，这里需要蛇形的打印出二叉树的层序遍历</p>
<h2 id="题目解析">题目解析</h2>
<p>这里题目很简单，就是打印的顺序和上一层的顺序是相反的，也就是说单数层和双数层的打印顺序是相反的，那么就是说我们在打印不同层的时候，我们打印的顺序是不一样的，也就是说在之前层序的基础上，我们这里要判断一下层数的判断。<br>
我们这里的代码使用的切片来进行数据的处理，这里我们还要注意的事情是我们在不同层打印顺序问题，使用到的是将顺序进行交换，就是在判断层数的基础上，我们将需要交换的位置进行交换。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1649258272528.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一致性hash算法]]></title>
        <id>https://IseEkko.github.io/post/yi-zhi-xing-hash-suan-fa/</id>
        <link href="https://IseEkko.github.io/post/yi-zhi-xing-hash-suan-fa/">
        </link>
        <updated>2022-04-04T08:57:04.000Z</updated>
        <content type="html"><![CDATA[<p>分布式缓存中的运用。</p>
<h2 id="分布式缓存">分布式缓存</h2>
<p>在我们的分布式应用中我们常常会用到分布式缓存，什么是分布式缓存，说简单点就是将缓存放在几台机器上，然后我们就会发现一个问题，我们怎么做到用户想要数据的时候将数据给到用户呢。</p>
<h2 id="一般的hash算法">一般的hash算法</h2>
<p>使用一般的hash算法呢，就是将值进行hash然后取余服务器的数量，然后就会得到数字，然后将数据放在对应编号的服务器中。<br>
但是这样的话，容错性和扩展性都很差，为什么呢？<br>
无论是多了一台机器还是少一台机器它的hash后取余的位置都会不一样，然后访问数据的时候，因为服务器数量的变化这里也是不一样的。也就是说如果出现宕机或者想要增加服务器，那么所有的缓存都会失效。<br>
为了避免这样的问题产生，我们就要使用到hash一致性算法</p>
<h2 id="hash一致性算法">hash一致性算法</h2>
<p>hash一致性算法，在hash一致性算法中，我们首先先生成一个2^32的圆，然后将服务器节点进行hash放在圆上，然后将数据进行hash，然后hash到的位置，我们进行顺时针的寻找，寻找到第一个节点，我们就会将数据存放在上面，然后这里我们需要注意的事情是，这里我们需要增加虚拟节点，因为在hash的时候我们的服务器节点不一定说就是均匀分布的，这个时候如果节点很少，可能就会发生一些数据的偏移，可能会出现大部分的数据存放在一个服务器上，然后这个时候对于这个服务器来说，这样的压力就会很大，所以我们通过将节点进行增加几个虚拟节点来解决这个问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组内部实现和基本使用]]></title>
        <id>https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/</id>
        <link href="https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/">
        </link>
        <updated>2022-03-24T11:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>了解go数组的细节</p>
<h2 id="数组的内部实现和基础功能">数组的内部实现和基础功能</h2>
<p>在go中数组是一个长度固定的数据类型，用于存储具有相同类型的元素的连续块。因为存储的空间是连续的，所以遍历和查找元素也是很方便和简单的。</p>
<h3 id="声明和初始化">声明和初始化</h3>
<p>一旦声明了数组的长度和数组类型那么久不能在改变了，在go中数组的长度和类型也是类型的判断属性。只有两个属性相同的时候才能判定这个两个数组相同。</p>
<h3 id="初始化">初始化</h3>
<p>第一种：声明一个数组，并设置为零值<br>
var array [5]int<br>
第二种：使用数组字面量声明数组<br>
array := [5]int{1,2,3,4,5}<br>
第三种：让go自动计算声明数组长度<br>
array ：= […]int{1,2,3,4,5}<br>
第四种：声明数组并指定特定元素的值<br>
array  := [5]int{1:10,2:20}</p>
<h2 id="使用数组">使用数组</h2>
<p>因为数组的地址空间是连续的，所以数组的效率是很高的。如果要访问数组中的某个元素，使用【】加上下标就可以进行访问。<br>
使用指针类型的数组的时候，里面存放的是地址。把一个指针数组赋值给另一个指针数组，这个时候这两个数组中存放的地址是相同的，也就是指向的同一个地址空间。</p>
<h2 id="多维数组">多维数组</h2>
<p>数组本身只有一个纬度，不过可以组合多个数组创建多位数组。这里就不再多说多位数组的相关知识了。</p>
<h2 id="在函数间传递数组">在函数间传递数组</h2>
<p>在go中传递一个值，都是以类型的方式进行传输的，也就是说传递一个数组，会复制一个完整的数组进行传输，也就是说无论数组多大我们都会进行数组的全复制然后进行传输。<br>
这样的话我们就会损失效率，我们解决的办法就是使用指针类型进行传输。这个时候传输复制的时候就只用复制8字节的指针类型了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NAT地址转换]]></title>
        <id>https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/</id>
        <link href="https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/">
        </link>
        <updated>2022-03-24T00:08:35.000Z</updated>
        <content type="html"><![CDATA[<p>NAT地址转换它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。<br>
实现的三种方法</p>
<h2 id="三种实现方法有利有弊">三种实现方法有利有弊</h2>
<h3 id="第一种">第一种</h3>
<p>静态地址转换，内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可网络对内部网以实现外部络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p>
<h3 id="第二种">第二种</h3>
<p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p>
<h3 id="第三种">第三种</h3>
<p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARP协议]]></title>
        <id>https://IseEkko.github.io/post/arp-xie-yi/</id>
        <link href="https://IseEkko.github.io/post/arp-xie-yi/">
        </link>
        <updated>2022-03-24T00:08:05.000Z</updated>
        <content type="html"><![CDATA[<p>ARP协议是一个mac地址和IP地址的一个映射关系，也就是系统通过ip找到他的mac地址。<br>
过程</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿数量]]></title>
        <id>https://IseEkko.github.io/post/dao-yu-shu-liang/</id>
        <link href="https://IseEkko.github.io/post/dao-yu-shu-liang/">
        </link>
        <updated>2022-03-22T15:09:58.000Z</updated>
        <content type="html"><![CDATA[<p>今天做了一个题目就是关于一个二维数组。</p>
<h2 id="题目解析">题目解析</h2>
<p>在这个题目里面，我们需要做的是判断岛的数量，在这里1表示的是岛屿，0表示的是海洋，相邻的1表示的是一个岛屿。然后看到这里，我们就想到了我们要使用的方法，就是遍历然后计算1的位置。<br>
如何判断相邻的1是一个岛屿，使用的就是dfs广度优先算法。</p>
<h2 id="解析源码">解析源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647961967703.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全排列问题]]></title>
        <id>https://IseEkko.github.io/post/quan-pai-lie-wen-ti/</id>
        <link href="https://IseEkko.github.io/post/quan-pai-lie-wen-ti/">
        </link>
        <updated>2022-03-21T15:16:30.000Z</updated>
        <content type="html"><![CDATA[<p>今天遇见的题目是全排列的问题，这里进行一个总结<br>
<img src="https://IseEkko.github.io//post-images/1647875887964.png" alt="" loading="lazy"><br>
题目解析<br>
今天进行全排列的解析，给一个数组，然后进行排列组合，给出最后所有的排列组合。有一定的经验所以我们可以画出下面这个图<br>
<img src="https://IseEkko.github.io//post-images/1647875897982.png" alt="" loading="lazy"><br>
这里我们可以很清楚的看到，这里使用的方式是回溯，那么我们就可以开始写这个代码了。<br>
这个题目在做的时候，我们使用到的是slice的一些方法，删除第k个元素，然后加入第k个元素。<br>
达到回溯的效果。<br>
解题源码<br>
<img src="https://IseEkko.github.io//post-images/1647875924078.png" alt="" loading="lazy">		<br>
稍微加一点难度就是这个数组是无序的有重复的数组。<br>
这个时候在循环的时候就要判断数组中重复的数字。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路由器和交换机的区别]]></title>
        <id>https://IseEkko.github.io/post/lu-you-qi-he-jiao-huan-ji-de-qu-bie/</id>
        <link href="https://IseEkko.github.io/post/lu-you-qi-he-jiao-huan-ji-de-qu-bie/">
        </link>
        <updated>2022-03-21T15:15:55.000Z</updated>
        <content type="html"><![CDATA[<p>路由器和交换机，他们位于不同的位置，<br>
交换机处于网络中的数据链路层，根据mac地址进行转发，一般用于构建简单的内部网络<br>
路由器，路由器是在网络层中进行工作的，根据的是ip地址进行转发的。一般用于构建复杂的网络。</p>
]]></content>
    </entry>
</feed>