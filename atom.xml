<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>BytesLzz</title>
    <updated>2022-04-13T07:32:47.904Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>做好每一件事，读好每一本书，天道酬勤</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, BytesLzz</rights>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--上下文建立]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-shang-xia-wen-jian-li/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-shang-xia-wen-jian-li/">
        </link>
        <updated>2022-04-13T06:52:28.000Z</updated>
        <summary type="html"><![CDATA[<p>对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter</p>
]]></summary>
        <content type="html"><![CDATA[<p>对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter</p>
<!-- more -->
<h2 id="上下文必要性">上下文必要性</h2>
<p>在书写web应用的时候，我们使用原始的库的时候，其中接受请求信息和返回的消息体是单独的存在，然后这样就会导致我们书写很多冗余的代码，然后在返回的时候我们需要返回json这个时候如果使用原生的库这个时候我们书写的代码是：</p>
<pre><code>obj = map[string]interface{}{
 &quot;name&quot;: &quot;geektutu&quot;,
 &quot;password&quot;: &quot;1234&quot;,
}
w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
w.WriteHeader(http.StatusOK)
encoder := json.NewEncoder(w)
if err := encoder.Encode(obj); err != nil {
 http.Error(w, err.Error(), 500)
}
</code></pre>
<p>然后如果我们封装了过后我们书写的代码是：</p>
<pre><code>c.JSON(http.StatusOK, gee.H{
    &quot;username&quot;: c.PostForm(&quot;username&quot;),
    &quot;password&quot;: c.PostForm(&quot;password&quot;),
})
</code></pre>
<p>这里我们可以明显的感受到我们的代码简单了很多，如果没有进行封装，这个时候我们使用起来是非常难受的。在这里我们需要知道的是，其实在web应用中，我们需要很多的工具，在处理请求的时候，例如，将来解析动态路由/hello/:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。<br>
也就是在这次会话的时候context就是一个会话的百宝箱，这个时候我们可以找到我们处理这次会话的所有工具。</p>
<h2 id="实现代码">实现代码</h2>
<pre><code>type H map[string]interface{}

type Context struct {
	// origin objects
	Writer http.ResponseWriter
	Req    *http.Request
	// request info
	Path   string
	Method string
	// response info
	StatusCode int
}

func newContext(w http.ResponseWriter, req *http.Request) *Context {
	return &amp;Context{
		Writer: w,
		Req:    req,
		Path:   req.URL.Path,
		Method: req.Method,
	}
}

func (c *Context) PostForm(key string) string {
	return c.Req.FormValue(key)
}

func (c *Context) Query(key string) string {
	return c.Req.URL.Query().Get(key)
}

func (c *Context) Status(code int) {
	c.StatusCode = code
	c.Writer.WriteHeader(code)
}

func (c *Context) SetHeader(key string, value string) {
	c.Writer.Header().Set(key, value)
}

func (c *Context) String(code int, format string, values ...interface{}) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;)
	c.Status(code)
	c.Writer.Write([]byte(fmt.Sprintf(format, values...)))
}

func (c *Context) JSON(code int, obj interface{}) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)
	c.Status(code)
	encoder := json.NewEncoder(c.Writer)
	if err := encoder.Encode(obj); err != nil {
		http.Error(c.Writer, err.Error(), 500)
	}
}

func (c *Context) Data(code int, data []byte) {
	c.Status(code)
	c.Writer.Write(data)
}

func (c *Context) HTML(code int, html string) {
	c.SetHeader(&quot;Content-Type&quot;, &quot;text/html&quot;)
	c.Status(code)
	c.Writer.Write([]byte(html))
}
</code></pre>
<p>在这里面我们将很多的工具进行了封装<br>
代码最开头，给map[string]interface{}起了一个别名gee.H，构建JSON数据时，显得更简洁。<br>
Context目前只包含了http.ResponseWriter和*http.Request，另外提供了对 Method 和 Path 这两个常用属性的直接访问。<br>
提供了访问Query和PostForm参数的方法。<br>
提供了快速构造String/Data/JSON/HTML响应的方法。</p>
<h2 id="对处理函数的改装">对处理函数的改装</h2>
<p>昨天我们进行了路由解析的书写，我们知道了继承了handler后我们就可以进行请求的处理，然后我们将处理的函数进行一个改装</p>
<pre><code>package gee

import (
	&quot;log&quot;
	&quot;net/http&quot;
)

type router struct {
	handlers map[string]HandlerFunc
}

func newRouter() *router {
	return &amp;router{handlers: make(map[string]HandlerFunc)}
}

func (r *router) addRoute(method string, pattern string, handler HandlerFunc) {
	log.Printf(&quot;Route %4s - %s&quot;, method, pattern)
	key := method + &quot;-&quot; + pattern
	r.handlers[key] = handler
}

func (r *router) handle(c *Context) {
	key := c.Method + &quot;-&quot; + c.Path
	if handler, ok := r.handlers[key]; ok {
		handler(c)
	} else {
		c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)
	}
}
</code></pre>
<p>我们将增加处理函数的方法放在了这里，然后对昨天的代码进行一个改装</p>
<pre><code>package gee

import (
	&quot;net/http&quot;
)

// HandlerFunc defines the request handler used by gee
type HandlerFunc func(*Context)

// Engine implement the interface of ServeHTTP
type Engine struct {
	router *router
}

// New is the constructor of gee.Engine
//这里进行了router的创建
func New() *Engine {
	return &amp;Engine{router: newRouter()}
}

func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) {
	engine.router.addRoute(method, pattern, handler)
}

// GET defines the method to add GET request
func (engine *Engine) GET(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;GET&quot;, pattern, handler)
}

// POST defines the method to add POST request
func (engine *Engine) POST(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;POST&quot;, pattern, handler)
}

// Run defines the method to start a http server
func (engine *Engine) Run(addr string) (err error) {
	return http.ListenAndServe(addr, engine)
}

//这里就是最后的处理函数，这里开始建立的上下文。
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	c := newContext(w, req)
	engine.router.handle(c)
}
</code></pre>
<p>在这里我们结合了今天写的context进行了一个改装。 然后我们今天的上下文建立就建立好了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[七天实现web框架--路由映射]]></title>
        <id>https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-lu-you-ying-she/</id>
        <link href="https://IseEkko.github.io/post/qi-tian-shi-xian-web-kuang-jia-lu-you-ying-she/">
        </link>
        <updated>2022-04-12T14:21:46.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在学习一个七天系列课程，然后在这里对自己学习到的东西进行一个总结。今天实现的是web框架中的路由映射。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在学习一个七天系列课程，然后在这里对自己学习到的东西进行一个总结。今天实现的是web框架中的路由映射。</p>
<!-- more -->
<h2 id="http-net包">Http-Net包</h2>
<p>在实现这个路由解析器的时候，我们首先要明白go原本的http/net包是如何实现路由解析定向的。<br>
其中重要的函数</p>
<pre><code>// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
 DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre>
<p>这里的函数参数，第一个是路径的函数，第二个是处理函数handle，这个函数最后调用的其实就是</p>
<pre><code>// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
</code></pre>
<p>也就是说实现了handler的接口，那么就有了处理请求的能力。那么我们来看实现handler这个接口的条件是什么。这里肤浅的解释一下这个go接口的实现，在go语言中是支持鸭子类型的，所以我们只要实现了接口里面的方法，那么就实现了这个接口。<br>
handler接口：</p>
<pre><code>type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
<p>实现这个接口我们就有能力处理网络的请求了。但是其中我们还有东西需要我们去了解<br>
首先就是我们如何获取网络请求中的路径呢？<br>
其实这个很简单，在我们的Request中其实是包含了请求的路径的，获取的方式：<br>
req.URL.Path<br>
获取了过后我们就可以将请求的路径和对应的函数的建立起映射的关系。<br>
在这里我们简单的演示了一下上面提到的基本的使用，也就是实现基本的网络请求处理。</p>
<pre><code>type engine struct {
}

func (e *engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	switch req.URL.Path {
	case &quot;/&quot;:
		fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, req.URL.Path)
	case &quot;/hello&quot;:
		for k, v := range req.Header {
			fmt.Fprintf(w, &quot;Header[%q] = %q\n&quot;, k, v)
		}
	default:
		fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)
	}
}
func main() {
	en := new(engine)
	log.Fatal(http.ListenAndServe(&quot;:9999&quot;, en))
}
</code></pre>
<p>然后我们就可以开始实现框架的第一步，路由映射关系。</p>
<h2 id="框架映射结构">框架映射结构</h2>
<p>最后实现的源码：</p>
<pre><code>package gee

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

// HandlerFunc defines the request handler used by gee
type HandlerFunc func(http.ResponseWriter, *http.Request)

// Engine implement the interface of ServeHTTP
type Engine struct {
	router map[string]HandlerFunc
}

// New is the constructor of gee.Engine
func New() *Engine {
	return &amp;Engine{router: make(map[string]HandlerFunc)}
}

func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) {
	key := method + &quot;-&quot; + pattern
	engine.router[key] = handler
}

// GET defines the method to add GET request
func (engine *Engine) GET(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;GET&quot;, pattern, handler)
}

// POST defines the method to add POST request
func (engine *Engine) POST(pattern string, handler HandlerFunc) {
	engine.addRoute(&quot;POST&quot;, pattern, handler)
}

// Run defines the method to start a http server
func (engine *Engine) Run(addr string) (err error) {
	return http.ListenAndServe(addr, engine)
}

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	key := req.Method + &quot;-&quot; + req.URL.Path
	if handler, ok := engine.router[key]; ok {
		handler(w, req)
	} else {
		fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)
	}
}
</code></pre>
<p>在这里我们可以看到的是我们这里的实现的效果和gin很像，这里我们建立了一个map，用来映射路由和函数，然后这里我们在存储的时候，我们还将请求的方法进行了一个存储，也就是说相同的路径但是不同的请求方式他最后调用的函数也是不一样的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[错误异常机制]]></title>
        <id>https://IseEkko.github.io/post/cuo-wu-yi-chang-ji-zhi/</id>
        <link href="https://IseEkko.github.io/post/cuo-wu-yi-chang-ji-zhi/">
        </link>
        <updated>2022-04-09T03:12:07.000Z</updated>
        <summary type="html"><![CDATA[<p>在编写程序的时候很容易遇见的一个问题，也是必须要处理的，今天简单的去了解了一下什么是错误什么是异常，在go中是如何处理的</p>
]]></summary>
        <content type="html"><![CDATA[<p>在编写程序的时候很容易遇见的一个问题，也是必须要处理的，今天简单的去了解了一下什么是错误什么是异常，在go中是如何处理的</p>
<!-- more -->
<h2 id="错误异常">错误异常</h2>
<p>在了解怎么做之前，我们首先应该要明白，什么是错误，什么是异常</p>
<ul>
<li>错误：可以预测</li>
<li>异常：不可预测<br>
在程序的编码中，我们写的代码有时候我们知道他可能会出现什么错，那么我们就叫做错误，比如说我们写的这个代码：</li>
</ul>
<pre><code>func pan(i int) {
	if i == 0 {
		err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
		panic(err)
	}
}
</code></pre>
<p>如果我们用这个判断除数的话，那么可以知道除数是不能为0的，如果出现了除数为0那么他肯定是错误的，这种可以预测的，我们称之为错误。其他的错误是我们没有预测那么那些错误就是异常。感觉说的有点小绕。<br>
其实简单的就是，预测的叫做错误没有预测的就是异常。</p>
<h2 id="如何进行处理">如何进行处理</h2>
<p>在go中如果我们执行了panic，我们会得到下面这种结构。首先我们来看一下我们执行的代码：</p>
<pre><code>func main() {
  pan(0)
  fmt.Println(&quot;main安全退出&quot;)
}
func pan(i int) {

  if i == 0 {
  	err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
  	panic(err)
  }
}
</code></pre>
<p>这里我们输入了0，那么肯定是会执行panic函数的，那么执行了panic函数过后程序就会直接被终止，所以我们会得到下面这个结果。</p>
<pre><code>/private/var/folders/55/2cf9m54s36q_1yf2j1svkf580000gn/T/GoLand/___go_build_awesomeProject1_2022_4_9_PanicAndRecover
panic: i 不能为 0 %!(EXTRA time.Time=2022-04-09 11:19:17.141969 +0800 CST m=+0.000072167)

goroutine 1 [running]:
main.pan(0x0)
        /Users/lizhongzheng/GolandProjects/awesomeProject1/2022-4-9/PanicAndRecover/main.go:16 +0xd0
main.main()
        /Users/lizhongzheng/GolandProjects/awesomeProject1/2022-4-9/PanicAndRecover/main.go:9 +0x24
</code></pre>
<p>这里会清楚的写到在那里执行执行了panic，然后panic的错误是什么等相关信息。<br>
但是我们这里就会产生一个疑问，如果我们的程序正在运行但是不想让这个Panic将我们的程序直接终止，我们应该怎么处理。我们看到这里的结果是直接终止了程序的执行，最后是没有回到主函数执行输出的。<br>
对着这种处理，在php和java中使用有try catch这个方法进行处理，但是在go中是没有的，那么应该如果进行类似的处理呢？<br>
这里我们就要使用到一个recover()函数了，这个函数和panic一般都是一起出现的，这个函数的作用就是处理panic报的错误，然后收集不让程序直接退出。<br>
这里我们来演示一下有recover这个函数后，程序的执行吧，还是先上我们执行的源码：</p>
<pre><code>func main() {
	pan(0)
	fmt.Println(&quot;main安全退出&quot;)
}
func pan(i int) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(&quot;检测到错误&quot;, err)
		} else {
			panic(&quot;检测失败&quot;)
		}
	}()
	if i == 0 {
		err := fmt.Sprintf(&quot;i 不能为 0 &quot;, time.Now())
		panic(err)
	}
}
</code></pre>
<p>这个我们使用的defer，延迟处理函数，然后在这里return前进行一个调用，对于defer函数在以后我们再进行讲解，在这里我们知道它是延迟处理就可以了。<br>
然后下面是我们的执行结果：</p>
<pre><code>/private/var/folders/55/2cf9m54s36q_1yf2j1svkf580000gn/T/GoLand/___go_build_awesomeProject1_2022_4_9_PanicAndRecover
检测到错误 i 不能为 0 %!(EXTRA time.Time=2022-04-09 11:27:48.221554 +0800 CST m=+0.000130459)
&lt;!-- more --&gt;

main安全退出
</code></pre>
<p>不错我们执行到了最后，main函数安全退出，我们就演示到这里了，这就是go处理错误和异常的方法了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go_context（1）]]></title>
        <id>https://IseEkko.github.io/post/go_context-xue-xi-1/</id>
        <link href="https://IseEkko.github.io/post/go_context-xue-xi-1/">
        </link>
        <updated>2022-04-08T08:25:53.000Z</updated>
        <summary type="html"><![CDATA[<p>一直对context这个东西保持一个神秘感，今天对这部分内容进行了一个查看，可能理解不是很到位。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一直对context这个东西保持一个神秘感，今天对这部分内容进行了一个查看，可能理解不是很到位。</p>
<!-- more -->
<h2 id="context是什么">context是什么</h2>
<p>首先对于context这个东西到底是什么，在之前我的学长们总是给说什么上下文，但是呢我总是不理解这个东西，上下文？？？一脸的问号，什么是上下文？<br>
在我们交流的语言中呢，比如英语这个玩意（我贼垃圾），比如一个单词在这里是这个意思，但是换个地方他就不是那个意思了，，，emm也不知道大家理解没有，大概就是这个意思。<br>
然后官方一点的回答，什么是context。这个东西是怎么产生的。<br>
其实这个东西是在go1.17的时候加入的官方库的，具体的产生和go的并发是有关系的，在go的编程中最重要的东西就是channel和goroutine这两个玩意。在我们写go程序的时候，我们需要调用函数，在调用的时候很有可能我们会开启一连串的goroutine，那么我们怎么来达到一个特殊数据的一些传递和对goroutine的关闭呢？通过信号量这个玩意，使用sync.Wait来对它进行一个信号量的管理，其实这样肯定是不好的。所以我们的contxet就诞生了。</p>
<pre><code>简单的来说：context的作用就是在不同的goroutine之间进行同步，请求特定的数据取消信号量以及处理请求的截止时间。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1649408733993.png" alt="" loading="lazy"></figure>
<h2 id="context的使用">context的使用</h2>
<p>现在我们来看一下这个玩意我们应该怎么使用</p>
<h3 id="context创建">Context创建</h3>
<p>要想使用那么第一步肯定就是对这个东西的创建。<br>
context包主要提供了两种方式创建context:</p>
<ul>
<li>context.Backgroud()</li>
<li>context.TODO()</li>
<li>这两个函数其实只是互为别名，没有差别，官方给的定义是：<br>
context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来。<br>
context.TODO 应该只在不确定应该使用哪种上下文时使用；<br>
所以在大多数情况下，我们都使用context.Background作为起始的上下文向下传递。<br>
我们可以查看一下这部分的源码：<br>
<img src="https://IseEkko.github.io//post-images/1649407256932.png" alt="" loading="lazy"><br>
我们可以很清楚的看见，这两个最后返回的东西其实是一样的。</li>
</ul>
<h3 id="四个重要的函数">四个重要的函数</h3>
<p>我们创建过后，我们可以看到他可以调用的四个重要函数</p>
<pre><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
</code></pre>
<p>这里我们看到了这个四个重要的函数，这里我们简单的说一下它是干什么用的，后面我再对四个函数进行一个详细的学习和总结</p>
<h3 id="withvalue携带数据">WithValue携带数据</h3>
<h3 id="withtimeout超时控制">WithTimeout超时控制</h3>
<h3 id="withcancel取消控制">withCancel取消控制</h3>
<h3 id="withdeadline就是对withcancel取消控制的调用">WithDeadline就是对withCancel取消控制的调用</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三数之和]]></title>
        <id>https://IseEkko.github.io/post/san-shu-zhi-he/</id>
        <link href="https://IseEkko.github.io/post/san-shu-zhi-he/">
        </link>
        <updated>2022-04-08T05:17:18.000Z</updated>
        <content type="html"><![CDATA[<p>三数之和，这个题目做过了很多次但是还是有点不清楚，今天重新做了一下。</p>
<h2 id="题目解析">题目解析</h2>
<p>这个题目理解起来还是很简单的，也就是在一个数组里面我们将三个数字加起来等于0那么记录一下就可以了，所以最后的输出肯定是一个二维数组。首先我们要做的事情就是找出来这些数字。<br>
这里我们使用迭代的方式，我们首先将数组进行排序，然后使用双指针的方式将数字找出来，首先我们先取出一个数字，然后我们就将一个三个数字的题目转换成一个两个数字的题目。<br>
然后我们在找两个数字的时候，因为我们的数组是进行了排序的，所以我们就将情况分解出来，也就是说如果最后三个数字的和大于零那么就是说明右边界太大了，那么我们就调整右边界，同理我们可以调整左边界。<br>
这里需要注意一个点，也就是我们在最后的结构，我们不要重复的，所以相同的数字我们就要将它排除，这里我们有三段代码做了这件事情。</p>
<h2 id="解题源码">解题源码</h2>
<pre><code>func threeSum(nums []int) [][]int {
  sort.Ints(nums)
  return TreeNum(nums)
}


func TreeNum(nums []int)[][]int{
   res := make([][]int,0)
   for i := 0;i&lt;len(nums)-2;i++{
       n1 := nums[i]
       if n1 &gt; 0{
           break
       }
       if i &gt; 0 &amp;&amp; n1 == nums[i-1]{
           continue
       }

       l,r := i+1,len(nums)-1
       for l &lt; r{
                n2 ,n3 := nums[l],nums[r]
                if n1+n2+n3 == 0 {
                    res = append(res,[]int{n1,n2,n3})
                    for l&lt;r &amp;&amp; nums[l] == n2{
                        l++
                    }
                    for l&lt;r &amp;&amp; nums[r] == n3{
                        r--
                    }
                }else if n1+n2+n3 &lt; 0{
                    l++
                }else{
                    r--
                }
       }
   }
   return res
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go语言并发-订阅者模式]]></title>
        <id>https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/</id>
        <link href="https://IseEkko.github.io/post/go-yu-yan-bing-fa-ding-yue-zhe-mo-shi/">
        </link>
        <updated>2022-04-07T07:44:39.000Z</updated>
        <content type="html"><![CDATA[<p>在之前的学习中，接触到了消息队列的一些知识，然后今天在看书的时候，发现了一个使用go channel完成了一个订阅者模式的并发demo。</p>
<h2 id="订阅者模式">订阅者模式</h2>
<p>关于订阅者模式，在这里给大家讲解一下，订阅者模式其实就是将产生的消息，给多个订阅者，然后订阅者可以看到这里订阅的消息。<br>
这里实现的时候呢，因为有并发的知识，所以我们用到了协程，下面我们来具体的实现一下。</p>
<h2 id="具体的实现流程">具体的实现流程</h2>
<h3 id="创建订阅者结构">创建订阅者结构</h3>
<pre><code>type (
	subscriber chan interface{}         //订阅者的通道
	topicFunc  func(v interface{}) bool //主题过滤器
)

//发布者对象
type Publisher struct {
	m           sync.Mutex               //读写锁
	buffer      int                      //订阅队列缓存大小
	timeout     time.Duration            //发布者超时时间
	subscribers map[subscriber]topicFunc //订阅者消息
}
</code></pre>
<p>上面我们定义了基本的订阅者的结构，上面也有对订阅者字段的解释，这里着重理解的东西就是：</p>
<pre><code>subscribers map[subscriber]topicFunc //订阅者消息
</code></pre>
<p>这个结构其实就是订阅者模式的一个重要的结构，这里存放的是订阅者的过滤器，也就是通过这个结构我们可以清楚的知道，订阅者订阅的是那个主题。</p>
<h3 id="构造函数">构造函数</h3>
<p>使用构造函数构造出订阅者的实体，然后进行后面的操作</p>
<pre><code>func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		buffer:      buffer,
		timeout:     publishTimeout,
		subscribers: make(map[subscriber]topicFunc),
	}
}
</code></pre>
<h3 id="添加订阅者信息">添加订阅者信息</h3>
<pre><code>//订阅全部，也就是不加入过滤器
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

//添加一个订阅者，同时订阅者是有过滤器的
//这里其实就是返回一个订阅者的信息，然后添加上过滤器
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}
</code></pre>
<p>这里就是添加订阅者，这里添加的时候添加订阅者的过滤器，也就是增加一个映射关系。</p>
<h3 id="添加主题">添加主题</h3>
<pre><code>//发布一个主题
func (p *Publisher) Publish(v interface{}) {
	p.m.Lock()
	defer p.m.Unlock()
	var wg sync.WaitGroup
	//这里返回的是订阅者，然后后面是返回的过滤器
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.sendTopic(sub, topic, v, &amp;wg)
	}
	wg.Wait()
}

//发布主题，可以容忍一定的超时
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}
	select {
	case sub &lt;- v:
	case &lt;-time.After(p.timeout):
	}
}
</code></pre>
<p>这里我们使用到的并发式的添加消息，这里使用到了sync.WaitGroup，进行协程的同步。</p>
<h3 id="关闭订阅者模式">关闭订阅者模式</h3>
<pre><code>//关闭发布对象，同时关闭
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()
	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}
</code></pre>
<h2 id="最后的测试">最后的测试</h2>
<pre><code>func main() {
	p := NewPublisher(100*time.Millisecond, 10)
	defer p.Close()
	all := p.Subscribe()
	golang := p.SubscribeTopic(func(v interface{}) bool {
		if s, ok := v.(string); ok {
			return strings.Contains(s, &quot;golang&quot;)
		}
		return false
	})
	p.Publish(&quot;hello,lzz&quot;)
	p.Publish(&quot;hello,golang&quot;)
	go func() {
		for msg := range all {
			fmt.Println(&quot;all:&quot;, msg)
		}
	}()
	go func() {
		for msg := range golang {
			fmt.Println(&quot;golang:&quot;, msg)
		}
	}()
	time.Sleep(3 * time.Second)
}
</code></pre>
<p>最后的输出结果：<br>
<img src="https://IseEkko.github.io//post-images/1649321380937.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打印齿形的二叉树层序遍历]]></title>
        <id>https://IseEkko.github.io/post/da-yin-chi-xing-de-er-cha-shu-ceng-xu-bian-li/</id>
        <link href="https://IseEkko.github.io/post/da-yin-chi-xing-de-er-cha-shu-ceng-xu-bian-li/">
        </link>
        <updated>2022-04-06T15:16:26.000Z</updated>
        <content type="html"><![CDATA[<p>层序遍历是一个很常见的一个算法结构，这里我们进一步的进行二叉树的学习，这里需要蛇形的打印出二叉树的层序遍历</p>
<h2 id="题目解析">题目解析</h2>
<p>这里题目很简单，就是打印的顺序和上一层的顺序是相反的，也就是说单数层和双数层的打印顺序是相反的，那么就是说我们在打印不同层的时候，我们打印的顺序是不一样的，也就是说在之前层序的基础上，我们这里要判断一下层数的判断。<br>
我们这里的代码使用的切片来进行数据的处理，这里我们还要注意的事情是我们在不同层打印顺序问题，使用到的是将顺序进行交换，就是在判断层数的基础上，我们将需要交换的位置进行交换。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1649258272528.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一致性hash算法]]></title>
        <id>https://IseEkko.github.io/post/yi-zhi-xing-hash-suan-fa/</id>
        <link href="https://IseEkko.github.io/post/yi-zhi-xing-hash-suan-fa/">
        </link>
        <updated>2022-04-04T08:57:04.000Z</updated>
        <content type="html"><![CDATA[<p>分布式缓存中的运用。</p>
<h2 id="分布式缓存">分布式缓存</h2>
<p>在我们的分布式应用中我们常常会用到分布式缓存，什么是分布式缓存，说简单点就是将缓存放在几台机器上，然后我们就会发现一个问题，我们怎么做到用户想要数据的时候将数据给到用户呢。</p>
<h2 id="一般的hash算法">一般的hash算法</h2>
<p>使用一般的hash算法呢，就是将值进行hash然后取余服务器的数量，然后就会得到数字，然后将数据放在对应编号的服务器中。<br>
但是这样的话，容错性和扩展性都很差，为什么呢？<br>
无论是多了一台机器还是少一台机器它的hash后取余的位置都会不一样，然后访问数据的时候，因为服务器数量的变化这里也是不一样的。也就是说如果出现宕机或者想要增加服务器，那么所有的缓存都会失效。<br>
为了避免这样的问题产生，我们就要使用到hash一致性算法</p>
<h2 id="hash一致性算法">hash一致性算法</h2>
<p>hash一致性算法，在hash一致性算法中，我们首先先生成一个2^32的圆，然后将服务器节点进行hash放在圆上，然后将数据进行hash，然后hash到的位置，我们进行顺时针的寻找，寻找到第一个节点，我们就会将数据存放在上面，然后这里我们需要注意的事情是，这里我们需要增加虚拟节点，因为在hash的时候我们的服务器节点不一定说就是均匀分布的，这个时候如果节点很少，可能就会发生一些数据的偏移，可能会出现大部分的数据存放在一个服务器上，然后这个时候对于这个服务器来说，这样的压力就会很大，所以我们通过将节点进行增加几个虚拟节点来解决这个问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组内部实现和基本使用]]></title>
        <id>https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/</id>
        <link href="https://IseEkko.github.io/post/shu-zu-nei-bu-shi-xian-he-ji-ben-shi-yong/">
        </link>
        <updated>2022-03-24T11:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>了解go数组的细节</p>
<h2 id="数组的内部实现和基础功能">数组的内部实现和基础功能</h2>
<p>在go中数组是一个长度固定的数据类型，用于存储具有相同类型的元素的连续块。因为存储的空间是连续的，所以遍历和查找元素也是很方便和简单的。</p>
<h3 id="声明和初始化">声明和初始化</h3>
<p>一旦声明了数组的长度和数组类型那么久不能在改变了，在go中数组的长度和类型也是类型的判断属性。只有两个属性相同的时候才能判定这个两个数组相同。</p>
<h3 id="初始化">初始化</h3>
<p>第一种：声明一个数组，并设置为零值<br>
var array [5]int<br>
第二种：使用数组字面量声明数组<br>
array := [5]int{1,2,3,4,5}<br>
第三种：让go自动计算声明数组长度<br>
array ：= […]int{1,2,3,4,5}<br>
第四种：声明数组并指定特定元素的值<br>
array  := [5]int{1:10,2:20}</p>
<h2 id="使用数组">使用数组</h2>
<p>因为数组的地址空间是连续的，所以数组的效率是很高的。如果要访问数组中的某个元素，使用【】加上下标就可以进行访问。<br>
使用指针类型的数组的时候，里面存放的是地址。把一个指针数组赋值给另一个指针数组，这个时候这两个数组中存放的地址是相同的，也就是指向的同一个地址空间。</p>
<h2 id="多维数组">多维数组</h2>
<p>数组本身只有一个纬度，不过可以组合多个数组创建多位数组。这里就不再多说多位数组的相关知识了。</p>
<h2 id="在函数间传递数组">在函数间传递数组</h2>
<p>在go中传递一个值，都是以类型的方式进行传输的，也就是说传递一个数组，会复制一个完整的数组进行传输，也就是说无论数组多大我们都会进行数组的全复制然后进行传输。<br>
这样的话我们就会损失效率，我们解决的办法就是使用指针类型进行传输。这个时候传输复制的时候就只用复制8字节的指针类型了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NAT地址转换]]></title>
        <id>https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/</id>
        <link href="https://IseEkko.github.io/post/nat-di-zhi-zhuan-huan/">
        </link>
        <updated>2022-03-24T00:08:35.000Z</updated>
        <content type="html"><![CDATA[<p>NAT地址转换它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。<br>
实现的三种方法</p>
<h2 id="三种实现方法有利有弊">三种实现方法有利有弊</h2>
<h3 id="第一种">第一种</h3>
<p>静态地址转换，内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可网络对内部网以实现外部络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</p>
<h3 id="第二种">第二种</h3>
<p>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</p>
<h3 id="第三种">第三种</h3>
<p>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</p>
]]></content>
    </entry>
</feed>