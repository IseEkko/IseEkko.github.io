<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://IseEkko.github.io/</id>
    <title>isekko</title>
    <updated>2022-03-15T14:45:35.335Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://IseEkko.github.io/"/>
    <link rel="self" href="https://IseEkko.github.io/atom.xml"/>
    <subtitle>对个人笔记的总结，这个网站的笔记将会是我经过提炼过后的笔记。</subtitle>
    <logo>https://IseEkko.github.io/images/avatar.png</logo>
    <icon>https://IseEkko.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, isekko</rights>
    <entry>
        <title type="html"><![CDATA[两个协程交替打印奇偶数]]></title>
        <id>https://IseEkko.github.io/post/liang-ge-xie-cheng-jiao-ti-da-yin-qi-ou-shu/</id>
        <link href="https://IseEkko.github.io/post/liang-ge-xie-cheng-jiao-ti-da-yin-qi-ou-shu/">
        </link>
        <updated>2022-03-15T14:43:08.000Z</updated>
        <summary type="html"><![CDATA[<p>常见的go工程问题</p>
]]></summary>
        <content type="html"><![CDATA[<p>常见的go工程问题</p>
<!-- more -->
<h2 id="解析">解析</h2>
<p>在go语言中，开启一个协程是很容易的，直接使用的是go关键字，这里需要我们注意的时候，我们如何做到两个协程的同步，这个让我一下想到的就是channel，使用channel来完成这个功能，我们用一个使用go关键字开启两个协程，然后通过通信做到这个功能。<br>
也可以不使用channel，使用纯go 开启协程来做这个事情，这里涉及到的就是调度的问题，我们使用调度的方式，也就是当奇数进行打印的时候答应完一个就让出cpu的使用权限，然后偶数同理，但是这里我们需要注意的事情就是我们一定要设置使用的cpu核心数是多少。这里因为是两个交替打印所以我们使用到的就是一个核心数量就可以了。</p>
<h2 id="实现源码">实现源码</h2>
<p><img src="https://IseEkko.github.io//post-images/1647355474623.png" alt="" loading="lazy"><br>
<img src="https://IseEkko.github.io//post-images/1647355482241.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Keep-Alive 和非 Keep-Alice的差别]]></title>
        <id>https://IseEkko.github.io/post/keep-alive-he-fei-keep-alice-de-chai-bie/</id>
        <link href="https://IseEkko.github.io/post/keep-alive-he-fei-keep-alice-de-chai-bie/">
        </link>
        <updated>2022-03-15T14:41:05.000Z</updated>
        <summary type="html"><![CDATA[<p>这里的意思就是保持连接，和不保持连接</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里的意思就是保持连接，和不保持连接</p>
<!-- more -->
<h2 id="理解">理解</h2>
<p>我们如何来理解这个问题呢，keep-alive 和非 keep- alive的区别。其实是很好理解的，我们在非keep-alive中我们请求一个资源我们就要建立一个连接，keep-alive就很好理解了，下面我们通过一个图片来看理解一下。<br>
<img src="https://IseEkko.github.io//post-images/1647355356596.png" alt="" loading="lazy"></p>
<h2 id="区别与缺点">区别与缺点</h2>
<p>两者的区别和缺点，我们也很好的能通过上图看出来<br>
非Keep-alive<br>
我们每请求一个资源我们就要进行一个连接，然后我们创建一个连接是需要付出相应的成本的，建立一个连接，客户端和服务端都要分配一个TCP的缓冲区和变量这样会对服务器造成严重的负担。<br>
Keep-alive<br>
keep-alive很好的解决了上面的问题，也就是对于服务器严重的负担，但是他也不是完美的，因为保持连接，很可能造成资源的无效占用。这就是对资源的一种浪费。<br>
当然我们也有相应的解决办法，也就是我们需要正确的设置keepalive-timeout的时间，超过这个时间过后我们就断开连接，这样我们就可以解决资源无效占用的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见的五大基本类型（1）]]></title>
        <id>https://IseEkko.github.io/post/chang-jian-de-wu-da-ji-ben-lei-xing-1/</id>
        <link href="https://IseEkko.github.io/post/chang-jian-de-wu-da-ji-ben-lei-xing-1/">
        </link>
        <updated>2022-03-15T14:38:10.000Z</updated>
        <summary type="html"><![CDATA[<p>这里讲解的是string的使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里讲解的是string的使用</p>
<!-- more -->
<h2 id="redis-key的基本操作">Redis Key的基本操作</h2>
<pre><code>•    keys * 查看当前库中的所有key值
•  exists  key 判断key是不是存在
• type key 查看类型
• del key删除对应的值
• unlink key 也是删除对应的数据
• expire key 10 设置过期时间  
• Select index 就是切换库
• Dbsize 查看key的数量
• Flushdb 清空当前库
• Flushall 清空所有的库
</code></pre>
<h4 id="del-key-和unlink-key的区别">del key 和unlink key的区别</h4>
<p>del key是直接删除，到那时unlink key做的是异步的删除操作</p>
<h2 id="redis字符串-string">Redis字符串 string</h2>
<p>string是一个基本的类型，一个key对应一个value，string是二进制安全的，也就是说可以便是任意的数据，只要是可以转换为字符串，那么就可以存储，在redis中string最多可以存储512MB</p>
<h4 id="基本的操作">基本的操作</h4>
<p>set是添加的操作，set key value。<br>
get是查询操作，get key 就可以取出来了。<br>
这里需要注意的事情：如果我们set已经存在的值的时候，就会覆盖这个key的值<br>
Append 是在后面添加，也就是go中的添加切片的操作<br>
Strlen key 获取值的长度<br>
Setnx key value 这个时候是如果没有这个key的时候才存储这个值，如果库中有这个key那么久不会存储这个值。<br>
Incr key 这个操作是把数字类型进行一个加一操作<br>
Decr key 这个操作就是把数字类型进行一个减1<br>
Incrby key 步长 这个就是自定义加多少<br>
Decrby key 步长 就是定义减多少的意思。<br>
需要注意的事情：redis中的incr是原子操作<br>
mset 同时设置一个或者多个key-value进行操作<br>
Msetnx 如果包含库中有的key的时候就不会成功，这里需要知道有一个那么所有都会失败<br>
Getrange key 开始结束的位置 获取范围的值<br>
Setrange key 开始为位置 值 这样就会覆盖<br>
Set key 过期时间 value  这样可以在设置值的时候同时设置过期时间<br>
Ttl age 可以查看还有多久时间过期<br>
Getset key value 取出旧值然后覆盖值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重建二叉树]]></title>
        <id>https://IseEkko.github.io/post/chong-jian-er-cha-shu/</id>
        <link href="https://IseEkko.github.io/post/chong-jian-er-cha-shu/">
        </link>
        <updated>2022-03-15T14:29:57.000Z</updated>
        <summary type="html"><![CDATA[<p>这里讲解的是利用前序和中序遍历的结果重建二叉树</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里讲解的是利用前序和中序遍历的结果重建二叉树</p>
<!-- more -->
<h2 id="题目解析">题目解析</h2>
<p>我们首先要知道的是前序遍历和中序遍历是怎么遍历的。前序遍历是，首先处理中间节点，然后处理左右节点。中序遍历的遍历方式是首先遍历左节点然后遍历中左右节点。理解了这个过后我们就可以开始使用构造这个二叉树了。<br>
我们首先可以明白的是，前序遍历的第一个节点就是头节点，然后通过头结点找到它在中序遍历的位置，然后通过这个位置，我们可以知道的是，在这个节点的左边是左子树，右边是右子树，然后我们就知道了左子树的结点个数和右子树的结点个数，这个时候我们就可以开始递归。然后我们就可以得到这个二叉树。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647355074803.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树查找最近公共祖先]]></title>
        <id>https://IseEkko.github.io/post/er-cha-shu-cha-zhao-zui-jin-gong-gong-zu-xian/</id>
        <link href="https://IseEkko.github.io/post/er-cha-shu-cha-zhao-zui-jin-gong-gong-zu-xian/">
        </link>
        <updated>2022-03-14T15:03:38.000Z</updated>
        <summary type="html"><![CDATA[<p>这个题目的难度就是，我们不是搜索树了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个题目的难度就是，我们不是搜索树了。</p>
<!-- more -->
<h2 id="解题思路">解题思路</h2>
<p>这个题目我们需要想到的是，我们的思路还是差不多的，但是这里不能在用二叉搜索树的那个方法了，我们还是需要遍历，但是遍历的方式我们要进行改变。<br>
我们还是从根开始遍历，我们遍历到叶子节点了这个时候我们需要做的就是返回并判断，最终找到我们需要找到了节点，还是左右节点分开。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647270531026.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉搜索树的最近公共祖先]]></title>
        <id>https://IseEkko.github.io/post/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/</id>
        <link href="https://IseEkko.github.io/post/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/">
        </link>
        <updated>2022-03-14T14:43:49.000Z</updated>
        <summary type="html"><![CDATA[<p>二叉搜索树的最近公共祖先，理解这个题目的本质</p>
]]></summary>
        <content type="html"><![CDATA[<p>二叉搜索树的最近公共祖先，理解这个题目的本质</p>
<!-- more -->
<h2 id="题目解析">题目解析</h2>
<p>对于这个题目，解题的步骤从根节点进行遍历，因为我们知道是，二叉搜索树的特性，通过比较大小进行遍历，这样回更加的快速并且保持正确性，然后把左右节点的路径都找到过后我们就开始进行比较，当发现相同的时候，并且是最后一个相同的时候这个就是最近的公共祖先。<br>
这个理解起来不是很难，但是需要我们理解到位。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647270127652.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[判断是否是完成二叉树]]></title>
        <id>https://IseEkko.github.io/post/pan-duan-shi-fou-shi-wan-cheng-er-cha-shu/</id>
        <link href="https://IseEkko.github.io/post/pan-duan-shi-fou-shi-wan-cheng-er-cha-shu/">
        </link>
        <updated>2022-03-13T02:36:08.000Z</updated>
        <summary type="html"><![CDATA[<p>开始的时候，没有什么思路，想了很久，最后还是看了解析，理解了一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>开始的时候，没有什么思路，想了很久，最后还是看了解析，理解了一下。</p>
<!-- more -->
<h2 id="题目解读">题目解读</h2>
<p><img src="https://IseEkko.github.io//post-images/1647139097672.png" alt="" loading="lazy"><br>
这个题目就是判断是不是完成二叉树。</p>
<h3 id="什么是完成二叉树">什么是完成二叉树</h3>
<p>对于完全二叉树的定义就是除最后一层的节点外，也就是说除了叶子节点外，其他的节点都是有左右节点的，对于叶子节点还要保持，左边是满的，右边可以是空的，也就是如图所示：<br>
<img src="https://IseEkko.github.io//post-images/1647139293818.png" alt="" loading="lazy"><br>
上面的三种都是完成二叉树，那么如何来判断呢？</p>
<h2 id="解题过程">解题过程</h2>
<p>这个题目的解题思路使用的是，标号的方式，我们给每一个节点标号，然后有一个计数的变量，那么我们最后判断我们标号的最大值是不是和计数的相同，如果相同那么就是完成二叉树，不然就不是。</p>
<h2 id="解题源码">解题源码</h2>
<figure data-type="image" tabindex="1"><img src="https://IseEkko.github.io//post-images/1647139484768.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表中环的入口结点]]></title>
        <id>https://IseEkko.github.io/post/lian-biao-zhong-huan-de-ru-kou-jie-dian/</id>
        <link href="https://IseEkko.github.io/post/lian-biao-zhong-huan-de-ru-kou-jie-dian/">
        </link>
        <updated>2022-03-05T14:34:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>原来遇见这个题目，被数学公式套路了，然后现在回过来学。并有了自己的思路。</p>
<h3 id="解法一">解法一</h3>
<p>今天想到了一个特别的想法，就是我们看这个题目其实想要考察我们的东西，很简单，就是去找到入口，那么我们如何找呢，我想的是首先我们要判断他是不是具有环，然后再去找他的入口，突然我的脑海里面出现了一个东西，map我突然恍然大悟，我们可以使用map去判断这个东西。<br>
使用到了是map[*ListNode]int<br>
当我们循环出现第二次的时候，那么这个节点就是入口，同时我们证明了这个是有环的。<br>
<img src="https://IseEkko.github.io//post-images/1646490954143.png" alt="" loading="lazy"><br>
就这样我们找了头节点。</p>
<h3 id="解法二">解法二</h3>
<p>解法二使用到的是快慢指针法。<br>
<img src="https://IseEkko.github.io//post-images/1646490959475.png" alt="" loading="lazy"><br>
这里我们需要好好的理解一下这个题目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nacos使用]]></title>
        <id>https://IseEkko.github.io/post/nacos-shi-yong/</id>
        <link href="https://IseEkko.github.io/post/nacos-shi-yong/">
        </link>
        <updated>2022-03-05T14:20:16.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>出现的问题就是，在我们大规模的集群过后，由于我们微服务的原因，我们的配置文件会修改起来比较麻烦，而且很容易改错，这个时候我们需要做的事情就是通过一个第三方的配置中心，进行配置，这里我们选择的nacos</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>出现的问题就是，在我们大规模的集群过后，由于我们微服务的原因，我们的配置文件会修改起来比较麻烦，而且很容易改错，这个时候我们需要做的事情就是通过一个第三方的配置中心，进行配置，这里我们选择的nacos</p>
<!-- more -->
<h2 id="使用">使用</h2>
<p>在我们分布式应用中，我们为更好的完成项目的配置，减少错误我们使用到了nacos，我们需要知道的事，我们如何使用。</p>
<h2 id="获取nacos配置文件">获取nacos配置文件</h2>
<p>下面的代码我们就得到了nacos中的配置文件，在里面我们需要注意的几个点：<br>
<img src="https://IseEkko.github.io//post-images/1646490164720.png" alt="" loading="lazy"></p>
<p><img src="https://IseEkko.github.io//post-images/1646490170989.png" alt="" loading="lazy"><br>
我们需要注意的事情，是在里面有缓存的配置，如果在断网，网络拥塞的时候我们，在这里的项目就会得到缓存中的配置文件，这个配置文件是在我们运行项目的时候，独自进行创建的。<br>
<img src="https://IseEkko.github.io//post-images/1646490180362.png" alt="" loading="lazy"></p>
<h2 id="将配置文件变成struct">将配置文件变成struct</h2>
<p>在里面我们不是直接将yaml变成struct，这里我们需要注意的是，我们首先用通过yaml转换成json，然后将json放在nacos中进行配置。</p>
<p><img src="https://IseEkko.github.io//post-images/1646490186797.png" alt="" loading="lazy"><br>
在进行映射的时候，我们要创建对应的结构体，然后结构体要设置对应的json tag。<br>
监听配置的改变<br>
我们这里还需完成对配置文件改变的监听。</p>
<p><a href="https://github.com/IseEkko/DEMO/tree/master/nacos_test">Demo地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表内指定区域间反转]]></title>
        <id>https://IseEkko.github.io/post/lian-biao-nei-zhi-ding-qu-yu-jian-fan-zhuan/</id>
        <link href="https://IseEkko.github.io/post/lian-biao-nei-zhi-ding-qu-yu-jian-fan-zhuan/">
        </link>
        <updated>2022-03-04T14:25:06.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>这个问题较之前的链表反转，存在很多不同的地方，这里我们将详细的进行说明</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>这个问题较之前的链表反转，存在很多不同的地方，这里我们将详细的进行说明</p>
<!-- more -->
<h3 id="思路总结">思路总结</h3>
<p>这个问题在面试中也是很容易考察的，我在书写的时候出现了思维上次的错误，查看了解析过后我发现了自己在这个问题上的不足。在这里一步一步的进行解析。<br>
首先我们要明白我们做的这次反转，只是反转链表中的一部分，所以我们在交换位置位置的时候要格外的小心。<br>
<img src="https://IseEkko.github.io//post-images/1646403991242.png" alt="" loading="lazy"><br>
上面是我们准备的示意图，我们看到这里还没有发现与之前的链表反转有什么不同。<br>
因为我们是需要交换其中的一部分，所以我们现在假设我们交换的是中间两个<br>
在这里我们首先需要做的就是移动至相关位置。<br>
<img src="https://IseEkko.github.io//post-images/1646403998343.png" alt="" loading="lazy"><br>
现在我们移动到了想要的位置后，下一步就是进行交换，这里在交换的时候我们需要判断我们要交换多少次。答案是n右边界-m左边界次，这里我们要演示的是交换的核心过程<br>
<img src="https://IseEkko.github.io//post-images/1646404004469.png" alt="" loading="lazy"><br>
从图中我们看到我们首先做的是，将Next指针指向cur.Next,然后更具上面的步骤进行，我之前没有思考到位的就是pre指针的用法，最先我让他在交换的过程中也跟着交换，这是不对的。从图中我们知道他始终要指向交换后的对头上。<br>
具体的实现代码如下：<br>
<img src="https://IseEkko.github.io//post-images/1646404010538.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>