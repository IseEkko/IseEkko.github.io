{"posts":[{"title":"使用zap日志","content":"使用zap日志 将日志打印到文件里面 package main import ( &quot;go.uber.org/zap&quot; &quot;time&quot; ) func NewLogger() (*zap.Logger, error) { ctg := zap.NewProductionConfig() ctg.OutputPaths = []string{ &quot;./myproject.log&quot;, } return ctg.Build() } func main() { looger, err := NewLogger() if err != nil { panic(err) } sugar := looger.Sugar() defer sugar.Sync() url := &quot;https://imooc.com&quot; sugar.Info(&quot;failed to fetch URL&quot;, // Structured context as loosely typed key-value pairs. &quot;url&quot;, url, &quot;attempt&quot;, 3, &quot;backoff&quot;, time.Second, ) } ","link":"https://IseEkko.github.io/post/shi-yong-zap-ri-zhi/"},{"title":"子集问题（1）","content":"使用回溯算法解决子集问题 题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subsets 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路图 这里很清楚的看出我们解题的思路，也是解回溯的一般思路 ","link":"https://IseEkko.github.io/post/zi-ji-wen-ti-1/"},{"title":"用户密码加密","content":"在我们写程序中会有密码，密码我们肯定是需要有加密的一个环节。那么我们这里介绍一下md5加密 加密算法的分类 这里我们可以看到分为两类 那么两类的区别在于那里呢？ 什么是对称加密 对于对称加密，最简单的理解就是，在加密和解密的时候使用的是同一把钥匙，这样对于用户来说是不安全的，因为我们一旦知道了加密算法的钥匙，那么所有的密码我都可以解密出来，这对于用户的账号安全是一个很大的威胁。 那么我们这里就引出了非对称加密。 什么是非对称加密 非对称加密，也就是密码不能被反解出来。那么我们也会遇见一个问题，不能反解那么我们忘记了密码那么我们应该怎么办呢？ 对于这个问题，我们使用的解决办法是使用一个链接发给用户进行修改，这样既保证了安全性，也解决了这个问题。 判断用户密码输入是否正确的问题，这里我们不能对数据库的密码进行解密，那么我们就转换一下思路，我们对用户输入的值进行加密，然后进行比对，这样这个问题就得到的解决。 这里我们详细的说明一下一个非对称加密，MD5 MD5 信息摘要加密算法 在go中，写md5加密算法是很容易的，因为有现成的包可以使用 func ginMd5(code string)string{ Md5 := md5.New() _,_ = io.WriteString(Md5,code) return hex.EncodeToString(Md5.Sum(nil)) } 使用的包是：&quot;crypto/md5&quot; 对于这里我们不用太纠结这里的函数，这里我们需要做的就是直接使用就可以了。 ","link":"https://IseEkko.github.io/post/yong-hu-mi-ma-jia-mi/"},{"title":"GIN中间件","content":"关于中间件的使用，和原理 使用中间件 关于中间件的使用，让我想到了gin.Default()和gin.new(）的区别，区别在什么呢，使用Default，默认是使用了两个全局中间件，那么我们查看default的源码，我们可以知道中间件是怎么使用的，下面我看一下default的源码： func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) return engine } 这里我们直接把目光看到：engine.Use(Logger(), Recovery())，这里直接使用use就使用的中间件。所以我们知道了使用中间件使用的是，use这个方法。 package main import ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; &quot;time&quot; ) func main() { //我们在前面的学习我们知道了，使用default。会默认的使用两个中间件。 //这我们为了演示使用中间件，这里我们就使用NEw创建 //r := gin.Default() r := gin.New() //使用logger中间件 r.Use(mylogger()) //使用recovery r.Use(gin.Recovery()) //上面的使用方法是为全局使用的。 /** 下面这个方式，是在这个组内的路由都会使用到这个中间件。 */ auth := r.Group(&quot;/goods&quot;, func(c *gin.Context) { }) auth.Use(authsre) auth.GET(&quot;/ceshi&quot;) auth.GET(&quot;/c&quot;) r.Run() } func authsre(context *gin.Context) { fmt.Println(&quot;goods中间件&quot;) } func mylogger() gin.HandlerFunc{ return func(c *gin.Context) { t := time.Now() c.Set(&quot;example&quot;,&quot;123456&quot;) c.Next() end := time.Since(t) fmt.Printf(&quot;耗时：%v \\n&quot;,end) status := c.Writer.Status() fmt.Println(&quot;状态：&quot;,status) } } func TokenReqiired()gin.HandlerFunc { return func(c *gin.Context){ var token string for k,v := range c.Request.Header{ if k == &quot;x-token&quot;{ if k == &quot;x-token&quot;{ token = v[0] } } } if token != &quot;bobby&quot;{ c.JSON(http.StatusUnauthorized,gin.H{ &quot;msg&quot;:&quot;未登录&quot;, }) return //这里只能使用c.Abort()就会阻止后面的逻辑的运行。用return 是没有用的 } c.Next() } } 上面就是我们使用中间件的方式。 原理解析 这里我们发现一个问题，在中间件中，我们使用了return处理逻辑的时候，发现我们不想让后面的逻辑运行，但是使用return还是使用了，那么这是为什么呢。 这里我们需要注意的就是这中间件执行的流程 这里我们知道我们使用中间件使用的是，use去注册调用的，这个时候我们查看一个他的源码： func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } 点开过后，我们发现这里有一个：group.Handlers // HandlersChain defines a HandlerFunc array. type HandlersChain []HandlerFunc 这里发现了一个切片，然后我们再去查看运行逻辑中，我们是怎么注册路由的，然后我们点开同样发现了这个切片，然后我们对比了一下，我们发现了一个问题，也就是中间件和运行的逻辑分别是不同的handler并不是一体的，他们会按照顺序被安排到这个切片中，所以我们return是无效的，这个时候我们应该怎么办呢。 这里原理也很简单，也就是我们不想去执行这些handler的时候，我们直接把后面的删除，或者把指针移到最后面就可以了。 使用到的方法是： c.Abort() 在上面我们书写的使用中间件源码中也有。 ","link":"https://IseEkko.github.io/post/gin-zhong-jian-jian/"},{"title":"GIN中的错误翻译","content":"我们在书写程序的时候，遇见报错对于一些程序员来说全英文的报错不是很友好，这里找到了一个错误翻译的方法 关于翻译器的导入 这里我们先要导入预备的资源，然后再创建翻译器 我们需要导入的包 &quot;github.com/gin-gonic/gin/binding&quot; &quot;github.com/go-playground/locales/en&quot; &quot;github.com/go-playground/locales/zh&quot; ut &quot;github.com/go-playground/universal-translator&quot; &quot;github.com/go-playground/validator/v10&quot; en_translations &quot;github.com/go-playground/validator/v10/translations/en&quot; zh_translations &quot;github.com/go-playground/validator/v10/translations/zh&quot; 导入这些包后我们就可以开始相关的书写了，这里大家需要注意的是，我们在书写的时候，导包可以是自动导入的，这里写出来是怕同学忘记有那些包，或者导包失败导致后序的代码无效。 初始化翻译器 //翻译的更换 func InitTrans(locale string)(err error){ if v,ok := binding.Validator.Engine().(*validator.Validate);ok{ //注册一个获取json的tag自定义方法 v.RegisterTagNameFunc(func(fld reflect.StructField) string { name := strings.SplitN(fld.Tag.Get(&quot;json&quot;),&quot;,&quot;,2)[0] if name == &quot;-&quot;{ return &quot;&quot; } return name }) zhT := zh.New()//中文翻译器 enT := en.New()//英文翻译器 uni := ut.New(enT,zhT,enT) trans,ok = uni.GetTranslator(locale) if !ok { return fmt.Errorf(&quot;uni.GetTranslator(%s)&quot;,locale) } switch locale{ case &quot;en&quot;: en_translations.RegisterDefaultTranslations(v,trans) case &quot;zh&quot;: zh_translations.RegisterDefaultTranslations(v,trans) default: zh_translations.RegisterDefaultTranslations(v,trans) } } return nil } 后面我们发现了一个问题，就是我们出现的效果是这样的有前缀的，结构体前缀，当然我们是不需要的所以后序我们添加上了： func RemoveTopStruct(fileds map[string]string)map[string]string { rsp := map[string]string{} for field ,err := range fileds{ rsp[field[strings.Index(field,&quot;.&quot;)+1:]] = err } return rsp } 这个方法我们可以得到tag。 然后我们在测试的时候，发现了一个问题，就是我们得到的错误，字段他没有按照tag来完成书写，这个时候我们加上了这一段代码实现功能。 //注册一个获取json的tag自定义方法 v.RegisterTagNameFunc(func(fld reflect.StructField) string { name := strings.SplitN(fld.Tag.Get(&quot;json&quot;),&quot;,&quot;,2)[0] if name == &quot;-&quot;{ return &quot;&quot; } return name }) 最后使用 在使用的时候，我们需要注意的事情，我们要注册一个全局的变量，这样才能在任何的地方使用。 var trans ut.Translator 创建完成后，使用 //初始化翻译 if err := InitTrans(&quot;zh&quot;);err != nil{ fmt.Println(&quot;初始化翻译器错误&quot;) return } router := gin.Default() router.POST(&quot;/login&quot;, func(c *gin.Context) { var login LoginForm if err := c.ShouldBind(&amp;login);err != nil{ errs ,ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK,gin.H{ &quot;msg&quot;:err.Error(), }) } c.JSON(http.StatusBadRequest,gin.H{ &quot;err&quot;: RemoveTopStruct(errs.Translate(trans)), }) return } c.JSON(http.StatusOK,gin.H{ &quot;msg&quot;:&quot;登录成功&quot;, }) }) ","link":"https://IseEkko.github.io/post/gin-zhong-de-cuo-wu-fan-yi/"},{"title":"GIN学习","content":"详细的学习gin的知识点，不是第一次学习了，这次梳理一个学习的文档出来 第一个gin程序 这里我们开始演示一下gin的开始程序，也就是快速入门。 我们来看一下代码： package main import &quot;github.com/gin-gonic/gin&quot; func main() { r := gin.Default() r.GET(&quot;/ping&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) }) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 这里我们详细的拆分一下这个代码， 导包 这里我们可以使用go mod进行包的导入 代码细节 第一行代码 r := gin.Default() 这个一行代码，就是产生了一个gin的实例 然后后面进行操作， r.GET(&quot;/ping&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) }) 这里面首先有一个GET方法，对于这个GET方法我们首先来看一下它的源码 // GET is a shortcut for router.Handle(&quot;GET&quot;, path, handle). func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodGet, relativePath, handlers) } 看到源码我们可以看到里面的参数，首先第一个参数就是注册的路径，然后第二个就是处理器的注册。 在这里我们注册的是一个匿名函数。当然我们也可以修改成： func pong(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) } func main() { r := gin.Default() r.GET(&quot;/ping&quot;, pong) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 在这里我们需要注意的就是这个函数的类型要是：func (c *gin.Context) 然后我们可以发现在传递参数的里面，我们使用的是gin.H 我们点开它的源码： // H is a shortcut for map[string]interface{} type H map[string]interface{} 我们看到了它就是一个map类型，因为在gin中经常使用的原因，所以开发者对它进行了封装。这样我们使用起来就更加的方便。 gin中new和Default的不同 在这里我们介绍两个方法，他们返回回来的都是一个*Engine 那么它们有什么不一样呢，在这里我们要知道的是不一样的点是使用Default后它会默认开启两个中间件，一个是recover一个是logger。 路由分组和URL 在我们的开发中，我们为了程序的可读性，我们一般会把路由进行分组。 也是为了后期更好的寻找路由。 那么我们如何进行分组呢？ 我们使用的是Group方法。 package main import &quot;github.com/gin-gonic/gin&quot; func pong(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) } //演示分组 func main() { r := gin.Default() group := r.Group(&quot;/v1&quot;) { group.GET(&quot;/ping&quot;, pong) } r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 获取url参数 这里我们通过url传入参数，那么我们怎么操作呢? package main import &quot;github.com/gin-gonic/gin&quot; func pong(c *gin.Context) { id := c.Param(&quot;id&quot;) c.JSON(200, gin.H{ &quot;message&quot;: id, }) } //演示分组 func main() { r := gin.Default() group := r.Group(&quot;/v1&quot;) { group.GET(&quot;/:id&quot;, pong) } r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 但是呢我们可以发现这个东西是有问题的，我们这里设定的是id，按照我们常识这里，我们知道id一般来说是数字，但是这里不管是数值还是什么都可以传输。 那么我们怎么进行限制呢？ 这里我们运用到了之后的表单验证的方式。 package main import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; ) type Person struct { ID string `uri:&quot;id&quot; binding:&quot;required,uuid&quot;` Name string `uri:&quot;name&quot; binding:&quot;required&quot;` } func main() { r := gin.Default() r.GET(&quot;/:name/:id&quot;, func(context *gin.Context) { var person Person if err := context.ShouldBindUri(&amp;person);err != nil{ context.Status(404) return } context.JSON(http.StatusOK,gin.H{ &quot;name&quot;:person.Name, &quot;id&quot;:person.ID, }) }) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 获取GET和POST参数 这两种方式是我们比较常见的方式。那么下面我们详细的说明一下 GET 使用到的方法有两个一个是DefaultQuery和Query。这两个方法的区别在于，前者是可以有默认值的，后者不能设置默认值 package main import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; ) func main() { r := gin.Default() r.GET(&quot;/name&quot;,name) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } func name(c *gin.Context){ name := c.DefaultQuery(&quot;name&quot;,&quot;lzz&quot;) c.JSON(http.StatusOK,gin.H{ &quot;name&quot;:name, }) } POST 在post中我们要取出参数，我们也有两个方法，两个方法的区别和上面是一样的。 分别是DefaultPostForm和PostForm。 package main import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; ) func main() { r := gin.Default() r.POST(&quot;/postname&quot;,Postname) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } func Postname(c *gin.Context) { posrname := c.DefaultPostForm(&quot;name&quot;,&quot;lzz&quot;) c.JSON(http.StatusOK,gin.H{ &quot;name&quot;:posrname, }) } 关于gin表单验证 我们在做web开发的时候，肯定是会遇见表单验证的需求的，表单验证也是为了一定的安全性。 关于表单验证这里我们直接上代码，详情可以查看官方文档。 package main import ( &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; ) type LoginForm struct { User string `form:&quot;user1&quot; json:&quot;user&quot; binding:&quot;required,min=3,max=10&quot;` Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;` } type SignUpForm struct { Age uint8 `form:&quot;age&quot; json:&quot;age&quot; binding:&quot;gte=1,lte=130&quot;` Name string `form:&quot;name&quot; binding:&quot;required,min=3&quot;` Email string `form:&quot;email&quot; binding:&quot;required,email&quot;` Password string `form:&quot;password&quot; binding:&quot;required&quot;` RePassword string `form:&quot;re_password&quot; binding:&quot;required,eqfield=Password&quot;` } func main() { router := gin.Default() router.POST(&quot;/login&quot;, func(c *gin.Context) { var login LoginForm if err := c.ShouldBind(&amp;login);err != nil{ fmt.Println(err.Error()) c.JSON(http.StatusBadRequest,gin.H{ &quot;err&quot;: err.Error(), }) return } c.JSON(http.StatusOK,gin.H{ &quot;msg&quot;:&quot;登录成功&quot;, }) }) router.POST(&quot;/sigin&quot;, func(context *gin.Context) { var siginUpForm SignUpForm if err := context.ShouldBind(&amp;siginUpForm); err != nil{ fmt.Println(err.Error()) context.JSON(http.StatusBadRequest,gin.H{ &quot;err&quot;:err.Error(), }) return } context.JSON(http.StatusOK,gin.H{ &quot;msg&quot;:&quot;成功&quot;, }) }) router.Run() } ","link":"https://IseEkko.github.io/post/gin-xue-xi/"},{"title":"路径总和","content":"计算二叉树路径上的和，是不是等于目标值。 题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 --&gt; 2): 和为 3 (1 --&gt; 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 这一个题目的思路不是很难，只是需要判断的东西会多一些，但是总体来说还是简单的。 这里我们还是使用递归来解答这个题目，使用的方法还是递归的三步骤 解题 首先确认须传入的参数和返回的参数值 这个题目最终是要判断是不是符合条件，所以我们的返回值我们用bool类型。因为我们还是对节点进行操作，所以我们传入的参数也就是节点，因为我们还要进行数值的判断，所以我们还要传入这个需要比对的值。 trave(root *TreeNode,targetSum int)bool 确定终止条件 这里我们的终止条件就是看到最后叶子节点的时候，我们最后得到的值是是不是对应的值 也就是： if root.Left == nil&amp;&amp; root.Right == nil&amp;&amp; targetSum == 0{ return true } if root.Left == nil&amp;&amp; root.Right == nil{ return false } 确定单层逻辑 这里我们确认一些单层的逻辑，也就是在这里我们用到了回溯的思想，如果我们没有找到相应的路径我们就回溯然后再次寻找，直到确认返回为止。 if root.Left != nil{ targetSum = targetSum - root.Left.Val if trave(root.Left,targetSum){ return true } targetSum = targetSum + root.Left.Val } if root.Right != nil { targetSum = targetSum-root.Right.Val if trave(root.Right,targetSum){ return true } targetSum = targetSum+root.Right.Val } return false 解题源码 最后我们通过上面的步骤得到了最终的代码； func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil{ return false } return trave(root,targetSum-root.Val) } func trave(root *TreeNode,targetSum int)bool{ if root.Left == nil&amp;&amp; root.Right == nil&amp;&amp; targetSum == 0{ return true } if root.Left == nil&amp;&amp; root.Right == nil{ return false } if root.Left != nil{ targetSum = targetSum - root.Left.Val if trave(root.Left,targetSum){ return true } targetSum = targetSum + root.Left.Val } if root.Right != nil { targetSum = targetSum-root.Right.Val if trave(root.Right,targetSum){ return true } targetSum = targetSum+root.Right.Val } return false } ","link":"https://IseEkko.github.io/post/lu-jing-zong-he/"},{"title":"二叉树的所有路径","content":"关于二叉树的所有路径的题目，这里我们是用递归的思想写出来的题目 题目 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [1,2,3,null,5] 输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 示例 2： 输入：root = [1] 输出：[&quot;1&quot;] 思路 我们这里使用的是递归的思想，也就是递归的三步骤，我们按照三步骤逐步的向下写 解题过程 首先我们思考第一步 定义函数确定返回值和输入值 func(node *TreeNode,path string) 这里传入的值是节点，然后和路径 确定终止条件 这的终止条件有些不一样，开始写的时候，我写的条件是 if root == nil{ ... } 显然这里的题目条件没有这么简单，所以我们这里需要注意一下这里的条件 ，因为如果是我之前书写的条件，那么我们后面就会有一大堆的判断，显然是不合理的。所以我们这里要思考一些终止条件。 我们知道，我们路径终止的条件是什么，是节点左右节点都为空，所以我们的终止条件就来了。 if (node.Left ==nil &amp;&amp; node.Right == nil){ 上面就是我们的终止条件 单层逻辑 这里的单层逻辑就不过多的赘述，我们直接上代码 if (node.Left ==nil &amp;&amp; node.Right == nil){ s := path + strconv.Itoa(node.Val) res = append(res,s) return } path = path + strconv.Itoa(node.Val) + &quot;-&gt;&quot; if node.Left != nil{ allpath(node.Left,path) } if node.Right != nil{ allpath(node.Right,path) } 最终题目代码 func binaryTreePaths(root *TreeNode) []string { var res []string var allpath func(node *TreeNode,path string) allpath = func(node *TreeNode,path string){ if (node.Left ==nil &amp;&amp; node.Right == nil){ s := path + strconv.Itoa(node.Val) res = append(res,s) return } path = path + strconv.Itoa(node.Val) + &quot;-&gt;&quot; if node.Left != nil{ allpath(node.Left,path) } if node.Right != nil{ allpath(node.Right,path) } } allpath(root,&quot;&quot;) return res } ","link":"https://IseEkko.github.io/post/er-cha-shu-de-suo-you-lu-jing/"},{"title":"GORM-使用","content":"这里将总结出使用gorm中的方法 开始连接 这里我们将开始学习使用gorm连接数据库，这里我们要知道后面我们使用的方法都是通过连接获取的对象进行操作的。那么下面我们就开始创建这个连接。 当然最开始我们肯定是要导入gorm包的，这里我们就不再展示了 这里在连接的时候，我们这里肯定是要先书写连接dns dsn := &quot;用户名:密码@tcp(ip:3306)/数据库名称?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot; 写好了这个连接名过后，使用 gorm.Open()进行连接的创建 db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{ Logger: newLogger, }) 上面我们就创建好了这个连接对象，然后后面的操作我们将在这个基础上进行。 基础使用的设置 配置彩色打印与日志级别 在前面我们说到，我们可能会对sql敏感度会降低，这里我们将解决这个尴尬的问题，我们这里可以让执行的sql语句打印出来，这里我们直接上代码是怎么配置的。 /** 进行日志配置，这里配置可以让他打印出sql */ newLogger := logger.New( log.New(os.Stdout, &quot;\\r\\n&quot;, log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容——译者注） logger.Config{ SlowThreshold: time.Second, // 慢 SQL 阈值 LogLevel: logger.Info, // 日志级别 IgnoreRecordNotFoundError: true, // 忽略ErrRecordNotFound（记录未找到）错误 Colorful: true, // 禁用彩色打印 }, ) //这里这个db就是生成的对象 db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{ Logger: newLogger, }) 这里我们就配置好了彩色打印。 这里我们设置的是全局的配置，也就是说，会打印出所有的语句。 设置表名 在开发的时候，我们知道在gorm中，我们添加表我们是先写好一个结构体，然后结构体的名称会影响最后生成表名的名称。这里我们有个需求也就是自定义表名的需求那么我们如何完成呢。这里我们将介绍两个办法。 通过方法进行修改 通过实现一个接口去实现对表名称的修改： func(Language) TableName()string{ return &quot;my_language&quot; } 在这里返回的值就是最后表的名称 通过配置完成名称前缀的添加 db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{ NamingStrategy: schema.NamingStrategy{ TablePrefix: &quot;mwwx&quot;, }, Logger: newLogger, }) 这里我们使用的是在生成连接对象的地方进行添加，我们在gorm.Open()中我们配置NamingStrategy: schema.NamingStrategy{}进行配置。这里我们添加的是表的前缀 需要注意的地方 这里我们需要注意的是。前面两个方法只能使用一个两个不能同时的使用，这里是需要我们注意的点。 基本的curd 创建表 在对数据进行操作之前，我们肯定是要先进行数据表的创建的，这里我们看一下我们如何使用gorm进行数据表的创建。 使用的方法是：AutoMigrate() db.AutoMigrate(&amp;表结构体{}) 这里需要注意的是我们这里使用的是结构体的 添加数据 有了数据表过后那么我们就要开始添加数据。 添加单条数据 //下面我们将会演示一个特殊的操作 user := User{ Name: &quot;lzz&quot;, } //这里我们需要注意的点，也就是这里我们在创建的时候使用的是地址 //然后我们这里是有返回值的 result := db.Create(&amp;user) //下面的步骤我们必须是有上面的操作过后才会有的操作。 fmt.Println(user.ID) fmt.Println(result.Error)//错误 fmt.Println(result.RowsAffected)//返回更新的条数 在这里我们可以看到添加单条数据的方法，然后我们可以看到最后的有三行代码，从中我们可以学习到，创建完对象过后我们可以做的操作和可以得到的数据。 批量添加数据 在批量添加数据中我们有两种方式可以完成。 使用create 这里我们使用到的方式是create var users = []User{ {Name: &quot;lzz1&quot;},{Name: &quot;lzz2&quot;},{Name: &quot;lzz3&quot;}, } result := db.Create(&amp;users) 这里我们可以清楚的看到，我们首先是创建了一个切片，然后我们使用切片去插入数据 使用CreateInBatches 这里我们使用的方法是使用CreateInBatches，为什么要使用这个方法呢，是因为上面的方法和这个方法的sql中我们就要看出差距，我们首先要知道的是，sql语句的长度是有限制的，但是上面的方法，在批量插入的时候，把所有的值都放到了一个sql里面，那么问题就来了这样的话当数据量很大的时候，由于sql是有限制的所有就会出错。这个时候我们就使用CreateInBatches这个方法，因为这个方法可以设定批量每一条sql的数量。 //这里可以设置提交几个数据，然后这里就是分批次进行创建 //那么我们为什么要用这个呢？是因为sql语句是有长度限制的，也就是数据量大的时候我们是没有办法 //进行传输的。这里进行限制的时候后面的数字代表的是一次创建创建几个数据。 db.CreateInBatches(users,2) 从上面我们就可以看出我们使用的方式。 查询 在使用gorm查询的时候，我们也有很多的点需要注意，在这里进行一个总结。 基本查询 在基本的查询中，我们使用的方法有first和find这个两个，对于这个两个方法，第一个查询的时候是根据主键进行排序的，返回第一条数据。然后find呢是返回的所有数据。 var product Product db.First(&amp;product, 1) // 根据整形主键查找 db.First(&amp;product, &quot;code = ?&quot;, &quot;D42&quot;) // 查找 code 字段值为 D42 的记录 find方式： //使用find会检索所有的对象。 var users []User result := db.Find(&amp;users) fmt.Println(&quot;总共记录：&quot;,result.RowsAffected) 当然肯定是不只是这些方式的： 对于其他的方式我们可以直接查看官方的文档。在我前一篇博客中有书写。 在查询中需要使用的where //在实际的开发中我们会加入很多的where语句的 db.Where(&quot;name = ?&quot;,&quot;lzz&quot;).First(&amp;users) //对于这里我们还可以这样去做查询，这样可以屏蔽很多的细节 db.Where(&amp;User{Name: &quot;lzz&quot;}).First(&amp;users) fmt.Println(users.ID) //在文档里面我们可以知道，我们还可以使用map，map和slice不同在于哪里？ //在于map不会屏蔽零值 /** 查询方式条件我们有三种方式： 1. string 2. struct 3. map 在这里面我们优先选择后两种。可读性更强 */ 需要注意的点 这里我们需要注意的是。我们使用的时候我们需要注意，因为我们使用的是地址，所以最后返回回来的数据，就在变量里面 在这里我们要是处理的时候我们没有查找到数据，是会有报错的 在这里我们使用最正规的的报错方式，这个方式可以准确的判断是不是没有找到数据 更新 更新这一板块也有很多常用的知识和需要注意的点 基础的更新 db.Model(&amp;product).Update(&quot;Price&quot;, 200) 这里是我们更新product表中的pricei字段为200 上面就是我们最基本的更新操作。 更新的时候遇见零值问题 这里我们需要注意的是，在gorm更新操作的时候，默认是不更新零值字段的。但是我们在实际的开发中肯定是有相关需求的，那么我们如何来解决这个问题呢？ 首先使用内置的函数sql.nullXXX 在gorm中我们是有相关的解决函数的，这里我们演示string类型字段零值的更新操作 db.Model(&amp;product).Updates(Product{Price: 200, Code: sql.NullString{ String: &quot;&quot;, Valid: true, }}) 如果接收更新零值我们这里第二个参数一定要改成true这样我们的方法才会生效。 改变字段结构体的类型 这里我们将字段的string类型改成了*string类型，那么他是可以更新零值的。 type User struct { ID uint Name string Email *string Age uint8 Birthday *time.Time MemberNumber sql.NullString ActivatedAt sql.NullTime CreatedAt time.Time UpdatedAt time.Time } //这里更新操作是会更新零值的 db.Model(&amp;User{ID: 1}).Update(&quot;Name&quot;,&quot;&quot;) 批量更新 批量更新的时候我们使用的是updates这个方法， db.Model(&amp;product).Updates(map[string]interface{}{&quot;Price&quot;: 200, &quot;Code&quot;: &quot;F42&quot;}) 需要注意的点 这里我们需要注意的是update会更新零值，但是updates不会更新零值。 删除 对于删除我们需要知道的点就是软删除和物理删除两个 在目前的市场上我们现在做到一般都是软删除，很少物理删除了，这里我们说一下gorm的软删除和物理删除。 在gorm中，我们需要进行软删除的换，我们需要在结构体里面嵌套一个，gorm.model结构体，主要的是DeletedAt gorm.DeletedAt字段，这个字段必须是gorm.DeletedAt这个类型的，这样我们删除的时候就是软删除了。 那么我们需要物理删除我们应该怎么做呢? db.Unscoped().Delete(&amp;NewUser{ID: 2}) } 使用这个方法我们就可以进行物理删除了。 结尾 最后我们这里总结的是一些基本的时候，和我们常用的curd使用的方法，当然总结的不是很到位，希望大家多多指教，后面我将会更新连表和钩子函数的总结。随后我也会把demo放在github上供大家查看。 ","link":"https://IseEkko.github.io/post/gorm-lian-jie/"},{"title":"gorm介绍","content":"gorm让我们从繁琐的sql中解脱出来， 努力的学习gorm，但是也别忘记了sql是怎么写的 GORM 这里不是我第一次学习gorm，只是这次想具体的去学习一下这个gorm，因为我的sql能力很弱，在写项目的时候清楚的看到了自己的不足，还有就是对gorm使用的不足，这里最关键的就是我其实对sql学得不是很好，后面还要更新对sql的学习，越到后面越发现这基础的重要性。 什么是GORM gorm就是go中封装的一种orm，orm对象关系映射，对于我们理解来说，就是一个为了让我们更好的操作数据库的一个工具。 下面我把官网放在下面。 GORM官网中文文档 对于GORM的感觉 其实对于这个gorm呢，在开发的时候确实速度是很快的，我们不用过多的在意sql是怎么写的。但是这样会弱化我们对sql的理解，所以我们觉得这个东西对于我们大学生来说，我认为我们写每一个方法的时候，我们多在意一下它生成的sql这样，我们不会弱化了我们对sql的理解。 当然了。我的sql很菜，我还是字学习gorm的时候，好好的学习一下sql，系统的学习一下。 上面就是我给大家分享的gorm，下面我将会更新gorm中使用的细节。 有那里写的不好的地方，希望大家多指教指教。 ","link":"https://IseEkko.github.io/post/gorm-jie-shao/"},{"title":"平衡二叉树","content":"什么是平衡二叉树？ 我们应该怎么去判断？ 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 思路 题目很简单，思路也很清晰，也就是我们去看树的高度差不大于1.我们只要依据这个条件去写代码就可以了 解题 func isBalanced(root *TreeNode) bool { if root == nil{ return true } if (!isBalanced(root.Left)||!isBalanced(root.Right)){ return false } Left := getDepath(root.Left)+1 Right := getDepath(root.Right)+1 if (abs(Left-Right)&gt;1){ return false } return true } func getDepath(root *TreeNode)int{ if root == nil{ return 0 } return max(getDepath(root.Left),getDepath(root.Right))+1 } func max(left,right int)int{ if left &gt;right{ return left } return right } func abs(num int)int{ if num&lt;0{ return -num } return num } ","link":"https://IseEkko.github.io/post/ping-heng-er-cha-shu/"},{"title":"二叉树的最小深度","content":"对于二叉树最小深度的解题相关，包含源码 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 思路 对于这个题目，最开始我是没有什么思路的，后面去看了解析才知道怎么写到。这里把之前看到的进行一个总结。 这个题目的主要思想就是后序遍历，后序遍历就是对树的中间节点进行最后的操作。 解题源码 func minDepth(root *TreeNode) int { return getDepth(root) } func getDepth(root *TreeNode)int{ if root == nil{ return 0 } left := getDepth(root.Left) right := getDepth(root.Right) if (root.Left ==nil&amp;&amp;root.Right != nil){ return right+1 } if (root.Left != nil&amp;&amp; root.Right == nil){ return left+1 } return 1+min(left,right) } func min(left,right int)int{ if left&lt;right{ return left } return right } ","link":"https://IseEkko.github.io/post/er-cha-shu-de-zui-xiao-shen-du/"},{"title":"二叉树的最大深度","content":"二叉树的最大深度。我们使用什么方法去破解？ # 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / 15 7 返回它的最大深度 3 思考 拿到这个题目我们最先想到的就是层序遍历，为什么呢？ 我们首先要明白层序遍历我们最后的结果是什么，层序遍历我们最后得到的是一个二位数组。 那我们换个角度去看他，最大的深度是不是就是层序遍历最后二维数组的层数。答案是肯定的。 上面是我最先能使用的方法。 解题 这里解题的方式有两种 递归法 这里我们回顾一下递归的三个要素。根据三要素来书写代码。 1. 确定输入和返回值 2. 确定终止条件 3. 确定单层逻辑 那么下面我们来详细的书写一下代码 首先我们确定输入和返回值，这里我们首先输入的肯定是节点，然后返回的是深度 function fun(){ func getDepths(root *TreeNode) int } fun(); 第二步是确定终止的条件，这里我们终止的条件是节点是nil if root ==nil{ return 0 } 第三步确定单层的逻辑 Left := getDepths(root.Left) Right := getDepths(root.Right) deth := 1 + max(Left,Right) 这里需要注意的是，我们最后得到的是高度，这里的高度是需要加一的。 最后的源码： func maxDepth(root *TreeNode) int { return getDepths(root) } func getDepths(root *TreeNode) int{ if root ==nil{ return 0 } Left := getDepths(root.Left) Right := getDepths(root.Right) deth := 1 + max(Left,Right) return deth } func max(Left,Right int)int{ if Left &gt; Right{ return Left } return Right } 迭代法 这个方法也就是我之前想到的那个方法，也就是使用层讯遍历去完成这个题目，这里我们就不在过多的解析 在后面的层序遍历的地方我会把这段代码详细的解析一遍。 func maxDepth(root *TreeNode) int { var res [][]int if root == nil{ return 0 } st:= list.New() st.PushBack(root) var Arrtem []int for st.Len() &gt; 0{ lenth := st.Len() for i := 0;i&lt;lenth;i++{ node := st.Remove(st.Front()).(*TreeNode) if node.Left != nil{ st.PushBack(node.Left) } if node.Right != nil{ st.PushBack(node.Right) } Arrtem = append(Arrtem,node.Val) } res = append(res,Arrtem) Arrtem = []int{} } result := len(res) return result } ","link":"https://IseEkko.github.io/post/er-cha-shu-de-zui-da-shen-du/"}]}