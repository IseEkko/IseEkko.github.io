{"posts":[{"title":"平衡二叉树","content":" 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 思路 题目很简单，思路也很清晰，也就是我们去看树的高度差不大于1.我们只要依据这个条件去写代码就可以了 解题 func isBalanced(root *TreeNode) bool { if root == nil{ return true } if (!isBalanced(root.Left)||!isBalanced(root.Right)){ return false } Left := getDepath(root.Left)+1 Right := getDepath(root.Right)+1 if (abs(Left-Right)&gt;1){ return false } return true } func getDepath(root *TreeNode)int{ if root == nil{ return 0 } return max(getDepath(root.Left),getDepath(root.Right))+1 } func max(left,right int)int{ if left &gt;right{ return left } return right } func abs(num int)int{ if num&lt;0{ return -num } return num } ","link":"https://IseEkko.github.io/post/ping-heng-er-cha-shu/"},{"title":"二叉树的最小深度","content":"题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 思路 对于这个题目，最开始我是没有什么思路的，后面去看了解析才知道怎么写到。这里把之前看到的进行一个总结。 这个题目的主要思想就是后序遍历，后序遍历就是对树的中间节点进行最后的操作。 解题源码 func minDepth(root *TreeNode) int { return getDepth(root) } func getDepth(root *TreeNode)int{ if root == nil{ return 0 } left := getDepth(root.Left) right := getDepth(root.Right) if (root.Left ==nil&amp;&amp;root.Right != nil){ return right+1 } if (root.Left != nil&amp;&amp; root.Right == nil){ return left+1 } return 1+min(left,right) } func min(left,right int)int{ if left&lt;right{ return left } return right } ","link":"https://IseEkko.github.io/post/er-cha-shu-de-zui-xiao-shen-du/"},{"title":"二叉树的最大深度","content":" # 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / 15 7 返回它的最大深度 3 思考 拿到这个题目我们最先想到的就是层序遍历，为什么呢？ 我们首先要明白层序遍历我们最后的结果是什么，层序遍历我们最后得到的是一个二位数组。 那我们换个角度去看他，最大的深度是不是就是层序遍历最后二维数组的层数。答案是肯定的。 上面是我最先能使用的方法。 解题 这里解题的方式有两种 递归法 这里我们回顾一下递归的三个要素。根据三要素来书写代码。 1. 确定输入和返回值 2. 确定终止条件 3. 确定单层逻辑 那么下面我们来详细的书写一下代码 首先我们确定输入和返回值，这里我们首先输入的肯定是节点，然后返回的是深度 function fun(){ func getDepths(root *TreeNode) int } fun(); 第二步是确定终止的条件，这里我们终止的条件是节点是nil if root ==nil{ return 0 } 第三步确定单层的逻辑 Left := getDepths(root.Left) Right := getDepths(root.Right) deth := 1 + max(Left,Right) 这里需要注意的是，我们最后得到的是高度，这里的高度是需要加一的。 最后的源码： func maxDepth(root *TreeNode) int { return getDepths(root) } func getDepths(root *TreeNode) int{ if root ==nil{ return 0 } Left := getDepths(root.Left) Right := getDepths(root.Right) deth := 1 + max(Left,Right) return deth } func max(Left,Right int)int{ if Left &gt; Right{ return Left } return Right } 迭代法 这个方法也就是我之前想到的那个方法，也就是使用层讯遍历去完成这个题目，这里我们就不在过多的解析 在后面的层序遍历的地方我会把这段代码详细的解析一遍。 func maxDepth(root *TreeNode) int { var res [][]int if root == nil{ return 0 } st:= list.New() st.PushBack(root) var Arrtem []int for st.Len() &gt; 0{ lenth := st.Len() for i := 0;i&lt;lenth;i++{ node := st.Remove(st.Front()).(*TreeNode) if node.Left != nil{ st.PushBack(node.Left) } if node.Right != nil{ st.PushBack(node.Right) } Arrtem = append(Arrtem,node.Val) } res = append(res,Arrtem) Arrtem = []int{} } result := len(res) return result } ","link":"https://IseEkko.github.io/post/er-cha-shu-de-zui-da-shen-du/"}]}